# Factory Method（工厂方法）
Factory Method（工厂方法）属于创建型模式，利用工厂方法创建对象实例而不是直接用 New 关键字实例化。工厂方法看似简单的将 New 替换为一个函数，其实是体现了面向接口编程的思路，它创建的对象其实是一个符合通用接口的通用对象，这个对象的具体实现可以随意替换，以达到通用性目的。
## 举例
**换灯泡**  
灯坏掉的时候，到五金店随便买一个灯泡就能用了  
**卡牌对战游戏**  
卡牌对战中，卡牌有一些基本属性，比如攻防、生命值，也符合一些通用约定，比如一回合出击一起等等，那么对于战斗系统来说，应该怎样实例化卡牌呢？如何批量操作卡牌，而不是通用功能也要拿到每个卡牌的实例才能调用？另外每个卡牌有特殊能力，这些特殊能力又应该如何拓展呢？  
**实现任意图形拖拽系统**  
一个可以被交互操作的图形，它可以用鼠标进行拉伸、旋转或者移动，不同图形实现这些操作可能并不相同，要存储的数据也不一样，这些数据应该独立于图形存储，我们的系统如果要对接任意多的图形，具备强大拓展能力，对象关系应该如何设计呢
## 解释
在使用工厂方法之前，要创建一个 用于创建对象的接口，这个接口具备通用性，所以我们可以忽略不同的实现来做一些通用的事情  
去门口五金店买灯泡，而不是拿到灯泡材料自己 New 一个出来，就是因为五金店这个 “工厂” 提供给我的灯泡符合国家接口标准，而我家里的灯座也符合这个标准，所以灯座不需要知道对接的灯泡是具体哪个实例，什么颜色，什么形状，这些都无所谓，只要灯泡符合国家标准接口，就可以对接上。  
对卡牌对战的系统来说，所有卡牌都应该实现同一种接口，所以卡牌对战系统拿到的卡牌应该就是简单的 Card 类型，这种类型具备基本的卡片操作交互能力，系统就调用这些能力完成基本流程就好了，如果系统直接实例化具体的卡片，那不同的卡片类型会导致系统难以维护，卡片间操作也无法抽象化。  
正是这种模式，使得我们可以在卡牌的具体实现上做一些特殊功能，比如修改卡片攻击时效果，修改卡牌销毁时效果。  
对图形拖拽系统来说，用到了 “连接平行的类层次” 这个特性，就是指一个图形，与其对应的操作类是一个平行抽象类，而一个具体的图形与具体的操作类则是另一个平行关系，系统只要关注最抽象的 “通用图形类” 与 “通用操作类” 即可，操作时，底层可能是某个具体的 “圆类” 与 “圆操作类” 结合使用，具体的类有不同的实现，但都符合同一种接口，因此操作系统才可以把它们一视同仁，统一操作。  
工厂方法第一句话就是 “定义一个用于创建对象的接口”，这个接口就是 Creator，让子类，也就是具体的创建类（ConcreteCreator）决定要实例化哪个类（ConcreteProduct）。  
使一个类的实例化延迟到其子类，是因为抽象类不知道要实例化哪个具体类，所以实例化动作只能由具体的子类去做，这样绕一圈的好处是，我们可以将任意多对象看作是同一类事物，做统一的处理，比如 无论何种灯泡实例都满足通用的灯座接口，所有工厂实例化的卡牌都具备玩一局卡牌游戏的基本功能，任何图形与交互类都满足特定功能关系

![image](./../../assets/images/design%20patterns/Factory%20Method.png)  

Creator 就是工厂方法，ConcreteCreator 是实现了 Creator 的具体工厂方法，每一个具体工厂方法生产一个具体的产品 ConcreteProduct，每个具体的产品都实现通用产品的特性 Product  

**代码例子**  
``` 
// 产品接口
interface Product {
  save: () => void;
}

// 工厂接口
interface Creator {
  createProduct: () => Product;
}

// 具体产品
class ConcreteProduct implements Product {
  save = () => {};
}

// 具体工厂
class ConcreteCreator implements Creator {
  createProduct = () => {
    return new ConcreteProduct();
  };
}
```
创建一个 Product 的子类 ConcreteCreator，并返回一个实现了 Product 的具体实例 ConcreteProduct，这样就可以方便使用这个工厂了。  
工厂方法并不是直接调用 new ConcreteCreator().createProduct 那么简单，这样体现不出任何抽象性，真正的场景是，在一个创建产品的流程中，我们只知道拿到的工厂是 Creator：  
``` 
function main(anyCreator: Creator) {
  const product = anyCreator.createProduct()
}
```
在外面调用 main 函数时，实际传进去的是一个具体工厂，比如 myCreator，但关键是 main 函数不用关心到底是哪一个具体工厂，只要知道是个工厂就行了，具体对象创建过程交给了其子类  
## 缺点
工厂方法中，每创建一种具体的子类，就要写一个对应的 ConcreteCreate，这相对比较笨重，但有意思的是，如果将创建多个对象放到一个 ConcreteCreate 中，就变成了 简单工厂模式，新增产品要修改已有类不符合开闭模式，推荐写成这种模式  


原文: 
[Factory Method（工厂方法）](https://github.com/ascoders/weekly/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/169.%E7%B2%BE%E8%AF%BB%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Factory%20Method%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E3%80%8B.md)
