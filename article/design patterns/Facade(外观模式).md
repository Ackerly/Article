# Facade(外观模式)
Facade（外观模式）属于结构型模式, 为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。  
## 举例
**图书管理员**  
图书馆是一个非常复杂的系统，虽然图书按照一定规则摆放，但也只有内部人员比较清楚，作为一位初次来的访客，想要快速找到一本书，最好的办法是直接问图书管理员，而不是先了解这个图书馆的设计，因为你可能要来回在各个楼宇间奔走，借书的流程可能也比较长。  
图书管理员就起到了简化图书馆子系统复杂度的作用，我们只要凡事询问图书管理员即可，而不需要关心他是如何与图书馆内部系统打交道的。  
**最多跑一次便民服务**  
浙江省推出的最多跑一次服务非常方便，很多办事流程都简化了，无论是证件办理还是业务受理，几乎只要跑一次，而必须要持续几天的流程也会通过手机短信或者 App 操作完成后续流程。  
这就相当于外观模式，因为政府系统内部的办事流程可能没有太大变化，但通过抽象出 Facade（外观），让普通市民可以直接与便民办事处连接，而不需要在车管所与驾校之间来回奔波，背后的事情没有少，只是便民办事处帮你做了。  
**Iphone 快捷指令功能**  
手机的 App 非常多，而我们需要了解每个功能在哪个 App 上才能运用自如，而快捷指令功能可以将 App 的某些功能单独提取出来，形成一套新的功能组，我们可以只接触到 “拍照” “付款” “计算”，而不用管背后是调用了支付宝还是微信、系统内置摄像机还是其他摄像 App，也不用关心这个 App 内部功能的入口在哪里，这些对接都在快接指令中自动完成。快捷指令也是一种外观模式。

## 解释

![image](./../../assets/images/design%20patterns/Facade.png)  

``` 
// 假设一个子系统是三个类结合使用的，为了抽象而解耦开了
class A {
  constructor(b: B) {
    this.b = b
  }
}

class B {
  constructor(c: C) {
    this.c = c
  }
}

class C {
  
}

// 它们组合成了一种常用功能，我们可以使用外观模式屏蔽子类的细节直接使用
class Compile {
  public run() {
    const parser = new A(new B(new C))
    parser.run()
  }
}

const compile = new Compile()
compile.run()
```
这样只要知道 Compile 类就可以了，而不需要了解背后的 A B C 以及其组合关系。
## 缺点  
外观模式并不适合于所有场景，当子系统足够易用时，再使用外观模式就是画蛇添足  
当系统难以抽象出通用功能时，外观模式的设计可能也无所适从，因为设计的高层接口可能适用范围很窄，此时外观模式的意义就比较小。
原文: 
[Facade（外观模式）](https://github.com/ascoders/weekly/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/176.%E7%B2%BE%E8%AF%BB%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Facade%20%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E3%80%8B.md)
