# Proxy代理模式
为其他对象提供一种代理以控制这个对象的访问
## 举例  
**获得文本对象长度**  
获得一个文本对象长度，必须要真正渲染出来，而渲染是比较耗时的，在某些场景下需要访问文本对象长度，而更多时候只需要读取文本内容，这两种操作耗时是完全不同的，如何做到业务层调用无感知，来优化执行耗时呢？  
代理模式可以解决这个问题，将业务层使用的文本对象替换为代理对象，这个代理对象初始化并不渲染文本，而是在调用文本长度时才渲染。  
**对象访问保护**  
某个大型系统开发完了，突然要求增加代码访问权限体系，不同模块对相同的底层对象拥有不同访问权限，此时这个权限控制逻辑如果写入底层对象，就违背了开闭原则，而对象本身的实现也不再纯粹，增加了维护成本，如何做到不修改对象本身，实现权限控制呢？  
代理模式也能解决，将底层对象导出替换为代理对象，由代理对象控制访问权限即可。  
**对象与视图双向绑定**  
Angular 或 Vue 这类前端框架采用双向绑定视图更新技术，即对象修改后，使用到的视图会自动刷新，这就需要做到以下两点：  
1. 在对象被访问时，记录调用的视图绑定。
2. 在对象被修改时，刷新调用它的视图。

在业务代码使用对象与修改对象的地方插入这段逻辑，显然会增加巨大的维护成本，如何做到业务层无感知呢？  
代理模式可以很好的解决这个问题，其实业务层拿到的对象已经是代理对象了，它在被访问与被修改时，都会执行固定的钩子做视图绑定与视图刷新。

![image](./../../assets/images/design%20patterns/Proxy.png)

Subject 定义的是 RealSubject 与 Proxy 共用的接口，这样任何使用 RealSubject 的地方都可以使用 Proxy。  
RealSubject 指的是原始对象，Proxy 是一个代理实体。  
当客户端要访问 subject 时，第一层访问的是 Proxy 代理，由这个代理将 realSubject 转发给客户端  
``` 
// 对象 obj
const proxy = new Proxy(obj, {
  get(target,key) {}
  set(target,key,value) {}
})
```

## 缺点
代理模式会增加微弱的开销，因此请不要将所有对象都变成代理，没有意义的代理只会徒增程序开销。  
另外代理对象过多，也会导致调试困难，因为代理层的存在，往往可能忽略这一层带来的影响，导致忘记这个对象其实是一个代理。

参考:  
[代理模式](https://github.com/ascoders/weekly/blob/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/178.%E7%B2%BE%E8%AF%BB%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20Proxy%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%8B.md)
