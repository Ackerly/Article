# 掌握正则表达式
正则表达式是匹配模式，要么匹配字符，要么匹配位置
## 表示位置
正则中常用来表示位置的符号主要有：^、$、\b、\B、?=p、(?!p)、(?<=p)、(?<!p)
### ^
> 匹配行的开头

例如要在hello的开头塞一个1
``` 
let string = 'hello'
console.log(string.replace(/^/, '1')) // 1hello
```
### $
> 美元符号，匹配行的结尾

在hello的结尾塞一个1
``` 
let string = 'hello'

console.log(string.replace(/$/, '1'))  // hello1
```
### \b
> 单词的边界，具体讲有三点规则。
1. \w和\W之间的位置
2. ^与\w之间的位置
3. \w与$之间的位置

把xxx_love_study_1.mp4变成❤xxx_love_study_1❤.❤mp4❤
``` 
'xxx_love_study_1.mp4'.replace(/\b/g, '❤') // ❤xxx_love_study_1❤.❤mp4❤
```
### \B
> 非单词的边界，也就是\b反着来的意思，它的规则如下：

1. \w与\w之间的位置
2. \W与\W之间的位置
3. ^与\W之间的位置
4. \W与$之间的位置

``` 
'[[xxx_love_study_1.mp4]]'.replace(/\B/g, '❤')

// 替换后
❤[❤[x❤x❤x❤_❤l❤o❤v❤e❤_❤s❤t❤u❤d❤y❤_❤1.m❤p❤4]❤]❤
```
### (?=p)
> 符合p子模式前面的那个位置。换句话说是，有一个位置，紧跟其后需要满足p子模式。也有一个学名叫正向先行断言。

xxx_love_study_1.mp4，要在xxx前面塞一个a
``` 
'xxx_love_study_1.mp4'.replace(/(?=xxx)/g, 'a') // axxx_love_study_1.mp4
```
### (?!p)
> (?=p)反过来的意思，可以理解为(?=p)匹配到的位置之外的位置都是属于(?!p)的，它也有一个学名叫负向先行断言。

``` 
'xxx_love_study_1.mp4'.replace(/(?!xxx)/g, 'a') 

// (?=xxx)的输出
axxx_love_study_1.mp4
// (?!xxx)的输出
xaxaxa_alaoavaea_asatauadaya_a1a.amapa4a

```
### (?<=p)
> 符合p子模式后面(注意(?=p)表示的是前面)的那个位置。换句话说是，有一个位置，其前面的部分需要满足p子模式。

``` 
'xxx_love_study_1.mp4'.replace(/(?<=xxx)/g, '#') //xxx#_love_study_1.mp4
```
### (?<!p)
> (?<=p)反过来的意思，可以理解为(?<=p)匹配到的位置之外的位置都是属于(?<!p)的

``` 
'xxx_love_study_1.mp4'.replace(/(?<!xxx)/g, '#') 

// (?<=xxx)的输出
xxx#_love_study_1.mp4
// (?<!xxx)的输出
#x#x#x_#l#o#v#e#_#s#t#u#d#y#_#1#.#m#p#4#
```
### 使用场景
1. 数字的千分位分割法  
将123456789转化为123,456,789  
**没三个数字前面添加一个,**
``` 
let price = '123456789'
let priceReg = /(?=(\d{3})+$)/g

console.log(price.replace(priceReg, ',')) // ,123,456,789
```
**取出守卫的逗号**
``` 
let price = '123456789'
let priceReg = /(?!^)(?=(\d{3})+$)/g

console.log(price.replace(priceReg, ',')) // 123,456,789
```
2. 手机号3-4-4分割  
将手机号18379836654转化为183-7983-6654
``` 
let mobile = '18379836654'
let mobileReg = /(?=(\d{4})+$)/g

console.log(mobile.replace(mobileReg, '-')) // 183-7983-6654
```
3. 手机号3-4-4分割扩展  
将手机号11位以内的数字转化为3-4-4格式
``` 
123 => 123
1234 => 123-4
12345 => 123-45
123456 => 123-456
1234567 => 123-4567
12345678 => 123-4567-8
123456789 => 123-4567-89
12345678911 => 123-4567-8911
```
**将第一个-弄出来**  
``` 
const formatMobile = (mobile) => {
  return String(mobile).replace(/(?<=\d{3})\d+/, '-')      
}

console.log(formatMobile(123)) // 123
console.log(formatMobile(1234)) // 123-
```
**将第二个-弄出来**  
将第一个-弄出来之后，字符的长度多了一位，原本1234567(这个位置插入-)8，要变成往后移一位
``` 
const formatMobile = (mobile) => {
  return String(mobile).slice(0,11)
      .replace(/(?<=\d{3})\d+/, ($0) => '-' + $0)
      .replace(/(?<=[\d-]{8})\d{1,4}/, ($0) => '-' + $0)
}

console.log(formatMobile(123)) // 123
console.log(formatMobile(1234)) // 123-4
console.log(formatMobile(12345)) // 123-45
console.log(formatMobile(123456)) // 123-456
console.log(formatMobile(1234567)) // 123-4567
console.log(formatMobile(12345678)) // 123-4567-8
console.log(formatMobile(123456789)) // 123-4567-89
console.log(formatMobile(12345678911)) // 123-4567-8911
```
4. 验证密码的合法性  
密码长度是6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符  
三个条件  
- 密码长度是6-12位
- 由数字、小写字符和大写字母组成
- 必须至少包括2种字符
**写出条件1和2和正则**
``` 
let reg = /^[a-zA-Z\d]{6,12}$/
```
**必须包含某种字符（数字、小写字母、大写字母）**  
``` 
let reg = /(?=.*\d)/
// 这个正则的意思是，匹配的是一个位置，这个位置需要满足`任意数量的符号，紧跟着是个数字`，注意它最终得到的是个位置，而不是数字或者是数字前面有任意的东西

console.log(reg.test('hello')) // false
console.log(reg.test('hello1')) // true
console.log(reg.test('hel2lo')) // true

// 其他类型同理
```
最终的表达式为
``` 
let reg = /((?=.*\d)((?=.*[a-z])|(?=.*[A-Z])))|(?=.*[a-z])(?=.*[A-Z])^[a-zA-Z\d]{6,12}$/


console.log(reg.test('123456')) // false
console.log(reg.test('aaaaaa')) // false
console.log(reg.test('AAAAAAA')) // false
console.log(reg.test('1a1a1a')) // true
console.log(reg.test('1A1A1A')) // true
console.log(reg.test('aAaAaA')) // true
console.log(reg.test('1aA1aA1aA')) // true

```
## 字符串匹配
### 两种模糊匹配
1. 横向  
> 一个正则可匹配的字符串的长度不是固定的，可以是多种情况，通过量词+、*、?、{m,n}，可实现横向匹配

``` 
let reg = /ab{2,5}c/g
let str = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc'

str.match(reg) // [ 'abbc', 'abbbc', 'abbbbc', 'abbbbbc' ]
```
2. 纵向  
> 一个正则匹配的字符串，具体到某一位字符时，可以不是某个确定的字符串，可以有多种可能，实现方式是字符组( 其实多选分支|也可以实现 )

``` 
let reg = /a[123]b/g
let str = 'a0b a1b a2b a3b a4b'

str.match(reg) // [ 'a1b', 'a2b', 'a3b' ]
```
### 字符组
1. 排除字符组  
> 某位字符可以是任何东西，但是就是不能是xxx, 使用^符号

常见简写形式
``` 
\d // 数字
\D // 非数字
\w // [0-9a-zA-Z_]
\W // [^0-9a-zA-Z_]
\s // [\t\v\n\r\f]
\S // [^\t\v\n\r\f]
```
2. 量词  
``` 
1. {m,} // 至少出现m次
2. {m} // 出现m次
3. ? // 出现0次或者1次，等价于{0,1}    
4. + // 至少出现1次,等价于{1,} 
5. * // 出现人一次,等价于{0,}  
```
### 贪婪匹配 VS 惰性匹配



参考：  
[就因为这三个知识点，我彻底学废了”正则表达式“](https://juejin.cn/post/7021672733213720613)
