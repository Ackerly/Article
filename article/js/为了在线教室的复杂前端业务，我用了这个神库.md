# 为了在线教室的复杂前端业务，我用了这个神库！
## 业务背景
完善的在线教室符合如下特点：  
1. 一个在线教室是有状态的，例如：一个教室可能处于课前、课中，可能正在进行随堂测验、抢答；
2. 在线教室内的各个功能，可以触发教室状态的流转，即事件驱动
3. 教室状态的流转存在一定的规则，例如，正在进行随堂测验，不能直接进入下课状态，必须先结束随堂测，然后下课；不同的业务形态，状态的流转规则可能不同，规则可配置
4. 在线教室通过状态的定时广播，达到广播老师端指令的目的

在线教室抽象出来就是一个状态机，状态包含各种状态，如聊天、轮播、签到、课件与激励等数十个状态，每个状态可能是在时间维度上有先后关系，每个状态也会有推 / 拉的操作，从而驱动状态的流转，状态的推 / 拉操作又是异步为主。  
针对这种复杂的、多状态、异步、注重时序控制的场景，天然有一种技术，或者说是一种编程思想是为此而生的，那就是 FRP（Functional Reactive Programming），而在 FRP 领域，ReactivX，简称 Rx，是由微软推出的通过可观察的流来进行异步编程的 API 则是 FRP 最经典的实现范本之一。  
而原教室中台的前端同学也是选择了 RxJS（Reactive Extension for JavaScript），通过 RxJS 整合了异步编程、时序控制以及各种遵循函数式编程思想的 Operators 的特性，优雅的实现了这种复杂的状态机。  
如学生列表服务：  
``` 
// packages/room/src/service/signalling/msg/fsm.ts
const fsmSubject = new Subject<classroom_common.IFsm | null>();
const behaviorFsmSubject = new BehaviorSubject<classroom_common.IFsm | null>(
  null
);
fsmSubject.subscribe(behaviorFsmSubject);

// packages/room/src/service/tools/stduent-list/index.ts
behaviorFsmSubject.subscribe((fsm) => {
  if (fsm) {
    const equipment = fsm.equipment;
    if (equipment) {
      const data = equipment.data;
      if (data) {
        const draftEquipment = EquipmentFsmField.decode(
          data
        ) as classroom_media_equipment.IEquipmentFsmField;
        this.subscribeEquipmentStateCb.forEach((cb) => cb(draftEquipment));
      }
    }
  }
});

export function pipeFsmMessage() {
  // ...
  const observable$$ = Emitter.on(MessageType.fsm);
  // ...
  
  observable$$.subscribe((payload) => {
    if (payload) {
      const currSeqId = Number(payload.seq_id);
      const biggerSeqIdComing = currSeqId > setId;

      if (biggerSeqIdComing) {
        fsmSubject.next(payload);
        setId = currSeqId;
      }
    }
  });
}

// packages/room/src/base.ts
export class RoomEngine {
  // ...
  async enterRoom() {
    // ...
    pipeFsmMessage(isBoe(), resp.fsm);
    // ...
  }
}
```
当状态机状态变化，即 MessageType.fsm 对应的状态变化，且现在服务端的 seq_id 大于前端保存的 seq_id 时，就会前端状态机对应的 fsmSubject 就会广播事件给到所有的订阅者，而 behaviorFsmSubject 订阅了 fsmSubject，之后在学生列表等其他状态中，又订阅了 behaviorFsmSubject，所以此时学生列表的相关状态就会变化，处理学生列表中设备信息的变化，如麦克风、摄像头、网络状况等，然后更新前端的 UI 显示。  
``` 
startFollowWidthRetry = (
    retryCount: number,
    delayTime: number,
    errorCb?: (err: Partial<RecorderStartResponse>) => void
  ) => {
    const sub$ = new Observable((observer) => {
      this.startFollowAudioRecord()
        .then((res) => {
          if (res.err_no) {
            return observer.error(res);
          }
          observer.next(res);
          observer.complete();
        })
        .catch((e) => {
          return observer.error(wrapNetworkError(e));
        });
    });

    return sub$
      .pipe(
        retryWhen((err$) => {
          return err$.pipe(
            scan((errCount, err) => {
              if (errCount >= retryCount) {
                throw new Error(err);
              }
              console.log("follow::retry", errCount);
              errorCb && errorCb(err);
              return errCount + 1;
            }, 0),
            delay(delayTime)
          );
        })
      )
      .toPromise();
  };
```
上述代码是实现学生跟读时音频录音的上报的逻辑，在这段代码中进行了学生跟读音频的录制上报、处理了错误，并提供了错误重试的机制等等，这段复杂的代码其实包含了一个典型的 RxJS 流的处理过程，并使用了大量的函数式 Operators（操作符），如 retryWhen 、scan 、delay 等  
上述代码乍一看其实是反直觉的，执行逻辑尚不明晰，再加上一大堆新名词，如 Observable 、observer 以及 pipe 还有上面提到的各种名为 Operators 的东西，更是让人头脑昏厥  
## 走入 RxJS
**牛刀小试**  
实现一个带 AutoComplete 的搜索框，输入内容时，自动向服务器发请求搜索对应的内容，然后将内容处理之后以列表的形式展示在输入框下面。  
对这个需求进行一下需求分析，来趴一趴实现这样的一个搜索框需要那些技术点：  
1. 首先最 naive 的，监听搜索框的 input 事件，每次有变化就发起一个请求，请求搜索服务器，拿到结果，然后丢给 UI 层去渲染
2. 接着需要过滤空输入、重复请求
3. 可能从性能方面考虑，需要加入防抖
4. 从容错性方面考虑，需要处理竟态
5. 更严谨一点，还需要处理失败重试
6. ...
一个实现上述 4 点功能的原生 JS 代码大概如下：  
``` 
const debounce = (fn, delay) => {
    let timer;

    return function (...args) {
      if (timer) clearTimeout(timer);
      timer = setTimeout(() => fn.apply(this, args), delay);
    };
  };

  const takeLatestRequest = (promiseCreator) => {
    let index = 0;
    return function () {
      index++;
      const promise = promiseCreator.apply(this, arguments);

      function guardLatest(func, reqIndex) {
        return function () {
          if (reqIndex === index) {
            func.apply(this, arguments);
          }
        };
      }

      return new Promise(function (resolve, reject) {
        promise.then(guardLatest(resolve, index), guardLatest(reject, index));
      });
    };
  };

  useEffect(() => {
    const inputSearch = document.querySelector(".search");
    const latestRequest = takeLatestRequest(searchWikiPedia);
    let lastInputValue = "";

    inputSearch.addEventListener(
      "input",
      debounce((e) => {
        if (!e.target.value) return;
        if (lastInputValue === e.target.value) return;
        else lastInputValue = e.target.value;

        latestRequest(e.target.value)
          .then((data) => setItems(data[1] || []))
          .catch((err) => console.log(err));
      }, 250)
    );
  }, []);
```
实现上述 4 点功能的 RxJS 代码大致如下：  
``` 
useEffect(() => {
    const inputSearch = document.querySelector(".search");
    fromEvent(inputSearch, "input")
      .pipe(
        map((e) => e.target.value),
        filter((val) => val),
        debounceTime(250),
        distinctUntilChanged(),
        switchMap((val) => searchWikiPedia(val))
      )
      .subscribe((data) => {
        setItems(data[1] || []);
      });
  }, []);
```
## 从数组聊起
其实 RxJS 和数组有解不开的因缘，为什么这么说呢？这就和 RxJS 的核心概念有关系，也和 FRP 编程思想有关系：   
ReactiveX 结合了观察者模式、迭代器模式与函数式编程的精华思想，其中迭代器模式和数组就有着不一般的关系，来看一个例子：  
``` 
let arr = ['a', 'b', 'c'];
let iterator = arr[Symbol.iterator]( "Symbol.iterator")

iterator.next(); // {value: 'a', done: false }
iterator.next(); // {value: 'b', done: false }
iterator.next(); // {value: 'c', done: false }
iterator.next(); //{value: undefined, done: true }
```
针对可迭代对象部署了统一的接口，使得这些对象能够按照统一的方式进行遍历，而无需关心内部的实现。  
同时数组还具有二维数组、可组合等特性：
``` 
let arr = ['a', ['b', 'c'], 'd'];

let arr2 = ['e', 'f', 'g'];
arr.concat(arr2); // ['a', ['b', 'c'], 'd', 'e', 'f', 'g']
```
数组还可以很好的结合函数式编程使用：  
``` 
arr.flat().map(item => item.toUpperCase()).reduce((total, item) => total += item)
```
上述操作将二维数组拍平，然后将每个字母转换为大写字母，接着进行聚合操作，拿到最后的结果：ABCD 。  
对数组有一个体感之后，我们再去看 RxJS 会感觉熟悉很多，虽然 RxJS 最核心的概念：Stream，相比数组多了一个时间维度的概念，可以理解为带上时间属性的 “数组”  
## RxJS 是什么
> 有各种语言的实现，如 RxJava，RxPy，RxGo 等等...，其中的 Rx 是指 Reactive Extension，指响应式编程（Reactive Programming）这种编程范式在 JavaScript 的一种实现。  

**什么是 Reactive Programming**  
这里可能会引出如下几个疑问？  
- 什么是观察者模式、迭代器模式？
- 什么是主动式（Proactive），什么是响应式（Reactive）
- 什么是命令式（Imperactive）、什么是函数式（Functional/Declaractive）、什么是响应式（Reactive）

**观察者模式与迭代器模式**  
观察者模式定了一个对象之间的一对多的依赖关系，当目标对象 Subject 更新时，所有依赖此 Subject 的 Observer 都会收到更新。  
举个例子:  
``` 
import { fromEvent } from "rxjs";

// 创建一个监听 document click 事件的 Observable
let Observable = fromEvent(document, "click");

// 通过 Observable.subscribe 时，接收一个 Observer 回调，当有点击事件（click）发生时
// 则调用传入的回调函数，即 Observer 会收到更新
let subscription = Observable.subscribe((e) => {
  console.log("dom clicked");
});

let subscription2 = Observable.subscribe((e) => {
  console.log("dom clicked");
});

let subscription3 = Observable.subscribe((e) => {
  console.log("dom clicked");
});
```
上述代码，当点击 DOM 时，三个 observer (回调函数）都会收到通知，然后打印 dom clicked 语句。  
迭代器模式是指提供一种方法顺序访问一个聚合对象中各个元素，而不需要暴露该对象的具体表示，常见的为部署 Symbol.iterator 属性，调用对应 Symbol.iterator 的方法返回一个迭代器对象，然后就可以以统一的方式进行遍历：  
``` 
let arr = ['a', 'b', 'c'];
let iterator = arr[Symbol.iterator]( "Symbol.iterator")

iterator.next(); // { value: 'a', done: false }
iterator.next(); // { value: 'b', done: false }
iterator.next(); // { value: 'c', done: false }
iterator.next(); // { value: undefined, done: true }
```
对应的 RxJS 里面就是 Observable 可观察对象，也就是我们后续将引出的 Stream 流的概念，每个 Stream/Observable 其实可以看作是一个数组，然后支持数组相关的各种操作、变换等，变成另外一个 Stream/Observable，拿 RxJS 举例：  
``` 
import { fromEvent, map } from "rxjs";

// 创建一个监听 document click 事件的 Observable
let subscription = fromEvent(document, "click")
    .pipe(map(e => e.target)
    .subscribe(value => {
      console.log('click: ', value);
    });
```
fromEvent(document, "click") 会声明一个 Observable 对象，同时也创建了一个 Stream，类似下面的图片：  
fromEvent(document, "click") 创建的 Observable 对应着上面的带有箭头的线，这条线就是一个 Stream 流，上面的一个个 ev 就是每次点击之后产生的事件，随着时间推移，不断的产生事件，在这个线上不断的流动下去 -- 之所以为 Stream，而这个 Stream 其实也可以看作是一个 “数组”，上面的一个个事件即为 “数组” 的元素，我们可以对这个 “数组”进行遍历，以统一的方式如 map/filter 等进行遍历，所以也叫融合了迭代器模式，而在 RxJS 中，通过这种 “迭代器” 模式，我们可以方便的对一个 Stream 进行变换  
而最后通过 subscribe 生成了 observer 观察者，当有事件发生时，observer 的回调函数会调用，打印 Log，即融合了观察者模式。  
那么函数式是如何应用在 RxJS 里面的呢？细心地同学可能发现了，RxJS 其实提供了大量的 Operators，如 map、filter、scan 等，以 函数式/声明式 的方式来操作 Stream，且操作之后生成一个新 Stream，不会突变原 Stream，此为融合了函数式编程思想。  
**主动式与响应式**  
Proactive（主动式）：即主动轮询，不停的去问需求方以期完成任务，常见的有设置一个定时器，不断的去给服务器发请求询问是否有新的内容产生。  
Reactive（响应式）：即有事件发生时，通知我完成任务，常见的有 DOM 事件的监听与触发、WebSocket 等  
举个例子  
> 完成目标：如平台中的上课通知，如果服务端收到新的课程开始通知，对应的客户端需要展示这些上课通知

通过主动式的方式会写出如下代码：  
``` 
setInterval(async function () {
  try {
    const classroomNotification = await fetch('https://xxx');
    // 后续操作
  } catch(err) {}
, 3000)
```
上述代码每隔 3S 去发一次请求，问一下服务端，现在数据有没有更新，有就把数据给我。  
通过响应式的方式去实现上述逻辑可能是如下：  
``` 
const socket = new WebSocket("ws://xxx");
socket.addEventListener('open', function() { // 连接成功，可以开始通讯 });
socket.addEventListener('message', function () {
  // 收到服务端传来的数据，修改前端数据，展示在前端
})
```
**上述代码每隔 3S 去发一次请求**  
命令式：你命令机器去做事情（how），得到你想要的（what）  
声明式：你告诉机器你需要什么（what），让机器想出如何去做（how）  
举个例子  
完成目标：拿到一个数组中的每项数字或包含数字的字符串，获得这些数字乘以 2 之后相加的结果。  
如果完成上述目标，用命令式的方式会写出如下代码：  
``` 
const source = [1, 5, 9, 3, 'hi', 'tb', 456, '11', 'yoyoyo'];
let total = 0;

for (let i = 0; i < source.length; i++) {
  let num = parseInt(source[i], 10);
  if (!isNaN(num)) {
    total += num * 2;
  }
}
```
即一步步的告知计算机要做什么（how），如遍历数组，对每一项进行 parseInt 操作，判断如果不是 NaN 时就相加，最后得到相加的结果（what）。  
通过函数式或者声明式的方式，会写出如下代码：  
``` 
const source = [1, 5, 9, 3, 'hi', 'tb', 456, '11', 'yoyoyo'];

let total = source
  .map(x => parseInt(x, 10))
  .filter(x => !isNaN(x))
  .map(x => x * 2)
  .reduce((total, value) => total + value )
```
上面的代码则是告知机器我想要什么（what），如我想要对数据进行映射（map）、过滤（filter）、再映射（map）、最后进行聚合（reduce）得到结果，由计算机自己想出如何进行 map、filter、reduce 等操作，我不需要关心 map、filter、reduce 底层的实现细节。  
**再看什么是 Stream？**  
Stream 是指时间序列上的一连串数据事件，而常见的数据事件（Data Event）包括 Variables、User Inputs、Properties、Caches、Data Structures 等各种同步或异步的操作，通过 Observe（观察）这些 Data Event，并依据其 Side Effects 进行对应的操作  
一个标准的流有开始态（黄色），有中间态（绿色、蓝色），有错误态（叉），有完成态（竖）  
- 黄色：对于一个点击事件，如 Click Event，当用户点击一个 DOM 元素时，触发了点击事件，这是一个数据事件。这是一个流的开始态。
- 绿色、蓝色：点击事件之后可能对数据进行了取值、缓存、或者声明新的数据结构进行存储等，这些也是数据事件。这是一个流的中间态。
- 叉：遇到 let 暂时性死区，未声明就使用，会抛出一个错误，这也是数据事件。这是一个 Stream 的错误态，错误态是一种完成态。
- 竖：点击以及点击之后的一系列操作执行完成，会到达一个 Stream 的完成态。

通过一段 RxJS 的代码来展现上述的 Stream：  
``` 
import { range, map } from "rxjs";

let source = range(1, 5);
let subscription = source
  .pipe(map(val => val * 2))
  .subscribe(
    (x) => console.log("onNext: " + x),
    (e) => console.log("onError: " + e.message),
    () => console.log("onCompleted")
);

// Logs:
// onNext: 1
// onNext: 2
// onNext: 3
// onNext: 4
// onNext: 5
// onCompleted
```
上述通过 RxJS 提供的 range operators 快速的创建了一个以 1 为起始值，长度为 5 的递增序列的 Stream
- 流的创建为起始态
- 对起始态的数据 1-5 进行后续的操作，为中间态，即将 1-5 映射为 2/4/6/8/10
- 如果在 Stream 的中间态遇到错误，进入到错误态，则会执行 subscribe 的第二个参数，，打印 onError: e.message
- 如果中间态执行完毕没有遇到错误，则会进入到完成态，执行 subscribe 的第三个参数，打印 onCompleted
- 同时，通过 subscribe 此 Stream，我们可以声明一个观察者（observer），当流中的数据事件发生副作用（Side Effects）时，做出对应的反应，对应到上述例子，此流后续会依次发出 1/2/3/4/5 等 5 个数据事件，这样 susbcribe 的第一个参数即会打印出 onNext: x 这样的 Log

**再看什么是 RxJS？**  
RxJS 最核心的概念就是 Observable（可观察对象）、Observer（观察者），当然还有一些 Subject、Scheduler 与 Operators 我们后续讲解  
Observable 就是我们上节提到的 Stream，RxJS 通过 Observable 这样一个可观察对象来具象化 Stream 的概念，通过一个例子来体会一下：  
``` 
import { fromEvent } from "rxjs";

// 创建一个监听 document click 事件的 Observable
let Observable = fromEvent(document, "click");

// 通过 Observable.subscribe 方法来声明一个观察者 observer，当有点击事件（click）发生时
// 则调用传入的回调函数
let subscription = Observable.subscribe((e) => {
  console.log("dom clicked");
});
```
Variables、User Inputs、Properties、Caches、Data Structures 等在 Stream 的概念中都是一个个数据事件，而 RxJS 可以将这些数据事件转换为 Observable，从而变成可观察对象，即创建为一个 Stream，然后此 Stream 则可以进行一系列 “中间态”，如进行 map 操作，最后到达“错误态”或“完成态”，同时在整个 Stream 的生命周期，我们可以 Subscribe（订阅）此流，声明一个 Observer（观察者），当 Stream 中的数据事件有 Side Effects 时，观察者就可以执行对应的操作。  
## RxJS 能做什么
**从 Stream 的视角来操作程序**  
从 RxJS 的视角来看，程序就是一个个 Stream 组成，无论是同步还是异步，无论是变量、事件等，都是一个个的 Stream，通过 RxJS，我们将这些数据事件转换为 Observable，然后进行 “流式” 操作。  
通过一个 RxJS 的例子来重新理解 Stream 这个概念，也就是 Observable 这个概念，来看下面这段代码：  
``` 
import { fromEvent, map, scan } from "rxjs";

// 创建一个监听 document click 事件的 Observable
 fromEvent(window, "click")
      .pipe(
        map((val) => 1),
        scan((total, curr) => total + curr)
      )
      .subscribe((val) => console.log(val));
```
> 我如果点击 4 次，打印的结果是什么？

答案是：1，2，3，4  
首先说明一下 scan 类似我们平时的 reduce，即对一组数据进行聚合，而 map 就和我们平时使用的 map 的作用一致，这两个都是对 Stream 进行了转换，而 subscribe 则是声明了一个观察者，一旦有数据过来，即打印这个数据。  
要理解上述结果，首先需要从 Stream 这个概念出来，去描绘整个处理过程，而首先需要关注的是 Stream 是一个具有 “时间” 这个维度的一个概念  
通过 fromEvent 创建了一个 Stream，也就是一个 Observable，然后随着时间推移，后续会触发多次 click 事件，即会在 Stream 这条线上，按时间维度触发这些 click 事件,这一系列的事件实际上组成了一个数组。  
通过 map 操作符，将数组中每个事件都映射成 1 这个数字，这里注意映射之后成为了一个新 Stream，这里称它为 stream 2，stream 2 中每个数据事件都是 1。  
接着继续调用 scan 操作符，scan 操作符类似 reduce，对传过来的数据进行聚合操作，但是这里为什么结果是 1， 2， 3， 4 呢？这里的核心就是需要理解我们 Stream 的核心，即从第一次点击开始，到后续的点击，这条流上共发生了 4 个数据事件，而每一次 scan 则会扫描从 stream 上面开始的第一个事件到当前发生的事件，并对这些数据进行聚合操作，所以结果计算如下：  
1. total 为 0，now 为 1，结果为 1
2. total 为 0，对 [1, 1] 进行聚合，结果为 2
3. total 为 0，对 [1, 1, 1] 进行聚合，结果为 3
4. total 为 0，对 [1, 1, 1, 1] 进行聚合，结果为 4

**对 Stream 进行组合**  
了解了 Stream 其实也是一个数组，但是 Stream 还拥有一个 “时间” 维度的概念，即随着时间的增长，Stream 上会不断的增加元素  
最能体现 RxJS 中对 Stream 这个具有时间维度属性的方法就是 merge  
因为 Stream 具有时间的属性，两个 Stream 合并之后会变成最下面的 Stream,如果在数组里对两个数组进行 merge 只能是 concat：  
``` 
let arr1 = [20, 40, 60, 80, 100]
let arr2 = [1, 1]

let arr3 = arr1.concat(arr2) // [20, 40, 60, 80, 100, 1, 1]
let arr4 = arr2.concat(arr1) // [1, 1, 20, 40, 60, 80, 100]
```
这就是时间属性在 Stream 上最明显的体现。  
通过一个实际的例子来了解组合的强大力量：  
> 给定一个需求，实现一个计数器，当点击 +/- 时能够正确的显示对应的数字

用常规的代码实现如下：  
``` 
import React, { useState } from "react";

export default function Merge() {
  const [count, setCount] = useState(0);

  const handlePlus = () => {
    setCount(count + 1);
  };

  const handleMinus = () => {
    setCount(count - 1);
  };

  return (
    <div>
      <div className="count">{count}</div>
      <button className="plus-button" onClick={handlePlus}>
        +
      </button>
      <button className="minus-button" onClick={handleMinus}>
        -
      </button>
    </div>
  );
}
```
上述代码很好懂，是完全的命令式的实现，即我加 1 的时候就手动加 1，减 1 的时候就手动减 1，我告诉计算机如何做（how），然后得到我要的结果 （what）  
然后切换成 RxJS 的形式：  
``` 
import React, { useState, useEffect } from "react";
import { fromEvent, merge, mapTo, scan } from "rxjs";

export default function Merge() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    merge(
      fromEvent(document.querySelector(".plus-button"), "click").pipe(mapTo(1)),
      fromEvent(document.querySelector(".minus-button"), "click").pipe(
        mapTo(-1)
      )
    )
      .pipe(scan((total, curr) => total + curr, 0))
      .subscribe((val) => {
        setCount(val);
      });
  }, []);

  return (
    <div>
      <div className="count">{count}</div>
      <button className="plus-button">+</button>
      <button className="minus-button">-</button>
    </div>
  );
}
```
可以看到由以下几个部分组成：  
- 将 plus-button 的点击事件转换成 Observable 可观察对象，每次点击就 mapTo(1) ，转为 1
- 将 minus-button 的点击事件转换成 Observable 可观察对象，每次点击就 mapTo(-1) ，转为 -1
- 将这两个 Stream 在时间维度上进行 merge

即前后点击 +1 与 -1，然后按照时间维度进行 merge，会变成最底部的形式，然后只需要执行最后一步，将所有的值加起来就是最终计数器的结果，这个时候用到 scan 这个聚合操作符，类似数组中的 reduce，执行聚合操作即可，然后将得到的值更新结果。  
可以看到通过 RxJS Stream 的思想，通过在时间维度上 merge 两个流，来实现计数器的效果，而在实现的过程中完全遵循声明式的写法，即你告诉计算机你要什么（what），然后计算机会自己推导出如何做（how），比如 mapTo 就是你告诉计算机每当一个点击事件发生时，我需要拿到数据 1，而 scan 则是告诉计算机我需要对数据进行聚合操作，然后计算机就会自动完成 merge 之后 Stream 的聚合操作。  
**对多重嵌套 Stream 进行处理**  
理解了 RxJS 将程序抽象为一个个 Stream 的概念，并且学习了从 Stream 的视角来操作程序，以及对多个 Stream 进行组合操作，接下来我们将探索如何在 Stream 中嵌套 Stream，然后又如何去处理这些多重嵌套的 Stream。  


参考:
[为了在线教室的复杂前端业务，我用了这个神库！](https://mp.weixin.qq.com/s/R0ybyiTM016srDU9mpMwnA)
