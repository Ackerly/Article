# CORS为什么能保障安全？为什么只对复杂请求做预检？
**什么是CORS**  
CORS的目的不是拦截请求，反倒是为了让其能正常请求。CORS诞生的背景是「同源策略」。这是一个相当严苛的规定，它禁止了跨域的AJAX请求。但实际的开发中又有这样的需求，于是开一个口子——只要配置了CORS的对应规则，跨域请求就能正常进行。这也正和CORS的名字对应起来了——「跨域资源共享」，就是为了能让跨域请求在「同源策略」的大背景下进行。  
**怎样配置CORS**  
完全后端来做：在响应头里面加一个字段Access-Control-Allow-Origin（允许请求的来源），这个值要把前端的源包含进去。  
举个例子：请求的后端接口是http://fe_nian，你本地正在开发前端工程跑在8080端口。那么后端会在响应头里加上Access-Control-Allow-Origin:*来允许http://localhost:8080这个源去做跨域请求，因为*是所有的意思。  
**跨域请求的流程**  
CORS把请求分成简单请求和复杂请求，划分的依据是“是否会产生副作用”  
同时满足下面这两个条件的是简单请求:  
1. 请求方法是HEAD/GET/POST
2. 请求体的文件类型只能是form-urlencoded、form-data、text/plain（这类文章很多，不再赘述，可以看阮一峰-跨域资源共享）

对于简单请求，流程如下：  
1. 浏览器发起请求，并且自动加上请求的来源origin给服务器检查；
2. 服务器返回数据，并返回检查结果，配置CORS响应头；
3. 浏览器检查CORS响应头，如果包含了当前的源则放行，反之拦截；

这里需要注意，浏览器是拦截响应，而不是拦截请求，跨域请求是发出去的，并且服务端做了响应，只是浏览器拦截了下来。  
对于复杂请求，整个流程如下：  
1. 浏览器发起预检请求，带上请求的来源origin，不包含请求体；
2. 服务器返回检查结果，配置CORS头；
3. 浏览器发起真正请求；
4. 浏览器返回数据；

**为什么要带上源**  
CORS给开发带来了便利，同时也带来了安全隐患——CSRF攻击。  
它的基本流程如下：  
1. 用户登录受害网站，把获取的身份凭证保存在浏览器的cookie中。也就是上图流程的①②③；
2. 用户用同一浏览器打开黑客网站，黑客网站向受害网站服务器发起一个恶意请求，这时浏览器会自动从cookie中取出身份凭证，把它带上。也就是上图的④⑤；
3. 受害网站服务端发现有身份凭证，恶意请求被成功受理；

如果严格按照同源政策，第2步的跨域请求不能进行的，也就不会造成危害。所以CORS策略的心智模型是：所有跨域请求都是不安全的，浏览器要带上来源给服务器检验。  
如果做过服务端开发，应该知道，服务端不存在跨域一说，去获取另一个服务器的资源是再顺畅不过的事情。因为服务端不像浏览器一样，作为“容器”存贮着用户身份凭证——也就是上面的第1步发生的事情，它去做跨域请求没有这样的风险。  

**为什么只对复杂请求做预检**  
划分简单请求和复杂请求的依据是“是否产生副作用”。这里的副作用指对数据库做出修改：使用GET请求获取新闻列表，数据库中的记录不会做出改变，而使用PUT请求去修改一条记录，数据库中的记录就发生了改变。  
对于简单请求，浏览器只会在请求头加上一个origin字段标识请求来源；对于非简单请求，浏览器会先发出一个预检请求，获得肯定回答后才会发送真正的请求，下面会讲清楚为什么这么做。  
可以假设网站被CSRF攻击了——黑客网站向银行的服务器发起跨域请求，并且这个银行的安全意识很弱，只要有登录凭证cookie就可以成功响应：  
1. 黑客网站发起一个GET请求，目的是查看受害用户本月的账单。银行的服务器会返回正确的数据，不过影响并不大，而且由于浏览器的拦截，最后黑客也没有拿到这份数据；
2. 黑客网站发起一个PUT请求，目的是把受害用户的账户余额清零。浏览器会首先做一次预检，发现收到的响应并没有带上CORS响应头，于是真正的PUT请求不会发出；

参考:  
[腾讯一面：CORS为什么能保障安全？为什么只对复杂请求做预检？](https://mp.weixin.qq.com/s/ulMSr3UPT5D9Kt12Vw25uA)
