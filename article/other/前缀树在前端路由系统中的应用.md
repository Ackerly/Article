# 前缀树在前端路由系统中的应用
## 前缀树介绍
前缀树，即字典树，又称 Trie 树。这种数据结构通常用来储存字符串，并且是以路径字符节点的形式来储存。拥有公共前缀的字符串，会共享同样的父节点路径。前缀树是通过利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。  
前缀树的 3 个基本性质：  
- 根节点不包含字符，除根节点外每一个节点都只包含一个字符
- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
- 每个节点的所有子节点包含的字符都不相同

## 路由匹配的场景  
这里的请求路径的形式可以当做就是一个个 URL 刨去协议名、域名、端口号（有的话）之后的部分，一般是通过斜杠 ("/") 来链接一个个元素，形如：
- /api/user/nameList
- /api/user/addressList

在大部分时候，路由的路径是根据模块的层级来划分功能，以达到顾名思义的目的，因此路由的路径其实是会有很多公共的前缀。比如，上述例子中同属于一个二级模块 User 的接口：  
/api/user/list 和 /api/user/create ，它们便有共同的前缀 /api/user ，联系到上述前缀树的性质，我们便可以通过前缀树来储存和搜索这些路由信息。  

## 应用到路由匹配中
把路由路径当做是用斜杠连接起来的 Component 的组合，因此前缀树当中的节点，储存的就不再是单个字符，而是一个个 Component，但这不会影响我们去使用这种数据结构来进行搜索。  
按照上面的描述，将这两串路径用 / 分割，形成一组 Component，同时它们拥有两层的公共路径，那么将会形成这样的树结构：（叶子节点储存的是对应的 handler）  
**将路由声明添加到 Trie 树中**  
面是将路由声明的 Component 添加到 Trie 树中的代码：  
router.get( '/api/user/nameList', xxx)
``` 
addToTree(urlPattern: string, handler: any) {
    let p = this.root;
    // Padding an element to the rear of the array to make the leaf node.
    const urlPatternComponents = [...urlPattern.split('/').filter(Boolean), LEAF_SIGN];

    urlPatternComponents.forEach(component => {
      const { quickMap } = p;

      // If quickMap has this component, it means the route has the same namespace
      // with existed route, so get to the next level directly. If the node is a leaf
      // node, just return cause it means redundant route is adding to the tree, we dont need it.
      if (p.quickMap.has(component as string)) {
        const node = p.quickMap.get(component as string)!;
        if (isLeafNode(node)) {
          return;
        }
        p = node;
        return;
      }

      if (component === LEAF_SIGN) {
        const newNode = new RouterTreeLeafNode(handler);
        quickMap.set(LEAF_SIGN, newNode);
        return;
      }

      const newNode = new NTreeNode(component as string);
      p.quickMap.set(component as string, newNode);
      // When the expression like ':id' shows in the route, it should
      // treat it as a parameter node.One tree node can only have one parameter node.
      if ((component as string).indexOf(':') > -1) {
        p.paramNode = newNode;
      }
      p = newNode;
    });
  }
```
router.get(' /api/hi/:name'  
这里用一个 quickMap 来储存子节点，key 为 Component，value 为节点，用于在匹配过程中快速查找到与 Component 值相匹配的节点。注意在 urlComponents 数组末尾填充了一个叫 LEAF_SIGN 的 Symbol，看上面的树结构图就知道，实际路由声明的 Component 遍历完之后，叶子节点的值储存的是最后一个 Component，因此我们需要给它添加一个子节点，用来储存实际匹配的结果，也就是路由的 Handler。paramNode 放到动态路由匹配一节再解析，这里可以先不管。
**静态路由匹配**  


原文:  
[前缀树在前端路由系统中的应用](https://mp.weixin.qq.com/s/8G8CvZAzRNnhsfF6WZoKWg)
