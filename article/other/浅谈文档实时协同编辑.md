# 浅谈文档的实时协同编辑
狭义的协同编辑指的是对纯文本（plain text）的编辑，此时我们的编辑对象是一个纯文本。随着数据结构变得复杂，也可延伸到富文本（rich text）和代码（code）。更广义的，协同编辑的概念可应用于任何结构化数据，例如图形（graph）和表格（sheet）。  
根据实时性要求的不同，可以把生活中的协同场景分为离线协同编辑和实时协同编辑。  

**离线协同**
离线协同编辑针对多个副本在不同时间对同一原本进行修改的场景。这意味着，副本产生的更改并不会马上应用到原本上，并且同一时刻只会有一个副本的更改会被应用到原本上。例如大部分在线配置文件、代码的版本管理、传统的网页博客编辑等。通常来说这种场景下默认大家都是有序进行编辑的，且最后完成编辑提交的副本决定文档原本的最终内容。根据合并策略的选择，还可以继续细分为覆盖式和非覆盖式。  
- 覆盖式：始终用最后提交的副本内容覆盖远程原本内容，也就是说最后提交的副本唯一决定着最终的原本内容。这种方式在实现上很简单，但是在实际使用中存在着多种问题，比如多个副本内容来回覆盖等。因此在某些场景下，还会引入编辑锁（edit lock），用以确保编辑行为的有序性。
- 非覆盖式：也称增量式，本地副本在提交时，总是会比较当前副本和远程原本的差异，只更新差异部分。相对于直接覆盖的方案，这种方案只应用变更部分，保证了多人合作的秩序。常见于代码版本管理中的差异补丁（diff-patch）。

**实时协同**  
实时协同编辑（real-time collaborative editing）指的是多个副本同时并行的对同一原本进行修改，满足物理意义上的实时性。在这个过程中更改的发生是频繁的，副本更改发生的顺序是不确定的，同时其它副本的更改也会及时的更新到本地。与离线编辑相比，实时编辑带来了许多新的挑战：  
- 写冲突。多个副本可能会在同一时间对同一位置（比如文档末尾）产生插入字符操作，此时最终的文档内容该如何决定？
- 删除冲突。如果多个副本同时删除了同一位置的字符，是否会产生重复删除问题，导致被删除的字符比预期的要多？
- 通信成本。实时场景下的编辑行为很频繁，需要不断的同步更改内容，随着文档规模的不断扩大，需要传输的字符串是不是越来越多？通信的成本是否会越来越高？
- 延迟问题。真实世界的网络通信存在延时，副本更改产生的时间顺序可能与到达服务器的时间顺序可能不一致，是否会导致因果关系的错乱？
- 断线重连。实际场景中，由于网络情况等诸多原因，如果某个副本在编辑时失去网络连接，在本地继续编辑一段时间后，重新连上服务器，此时服务器上的数据已经不再是断线前一瞬间的版本，该如何处理同步冲突？

**协同模型**  



参考:
[浅谈文档的实时协同编辑](https://mp.weixin.qq.com/s?__biz=Mzg2ODQ1OTExOA==&mid=2247497168&idx=1&sn=7ba58e4d7004446acde17f4ab8cc29e7&scene=21#wechat_redirect)
