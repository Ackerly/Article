# 寻找框架设计的平衡点
## 服务范围
服务范围是比较难翻译的单词，在原PPT中 用了“Scope”这个词表示，可以理解为“作用域、框架的承诺功能范围、服务配套齐全程度”。比如提供的是一个工具库还是整体框架，插件管理是集中式还是依赖生态。  
React是典型的小服务范围框架，核心包只实现了基本功能，其他生态靠社区拓展，Angular是典型大服务范围框架，官方对所有业务场景都做了最佳实践能力覆盖；Vue处于中间区域，通过功能分层，既拥有小服务范围的能力，又可以搭配官方插件实现更多场景化能力。  
**小服务范围特点**
- 概念  
小的服务暴露的基本能力较少，概念比较少，上手快。复杂场景无法支持引入新概念解决时，导致后续技术选型可能产生分歧，带来持续的新概念理解成本。
- 生态  
很多功能没有被官方实现，社区有机会填补这些空白，因此会冒出许多第三方库，而已一旦做得好，就有机会成为“事实标准”，因此开发者会更加积极参与到社区开发，自己做得框架“上升空间”也非常大。但是随着时间的流逝会涌现一些新的设计模式，成为当下必不可少的方案，但不会出现在官方文档中，造成选型时的疑惑。Redux就是一个例子。
- 维护  
核心代码少，维护成本降低，官方可以将精力放在更多核心能力增强上，比如Suspense等，而不是将精力消耗在生态插件上。非官方的生态意味着不稳定，缺乏统一的管理，碎片化的模块之间可能经常出现不兼容的问题。任何模块都可能被时代无情的淘汰，就像Flux到？Redux再到Hooks，带来额外的迁移成本和认知成本。谁也不希望自己项目架构“变得过时”或者随时面临被新架构取代的风险 ，但第三方社区几乎代表未来会出现一种模式取代现有模式，只是时间早晚而已。  
**大服务的特点**  
- 概念  
全家桶的概念导致上手难度偏高，因为必须理解所有内置概念后才能开始项目
- 场景
减少不必要的技术方案调研和纷争，大服务范围的框架内置的方案就能解决几乎100%业务问题，团队不会为通用架构问题烦恼了。但是发生内置功能无法满足业务场景就很难拓展了,因为all in one的思路本质就是排斥自定义拓展的，这点angular-cli括看出。死板是因为没法优雅解决，只能在现有约束通过某些“Hack”方式解决。
- 维护
官方维护作为背书，几乎不会出现一些生态包突然不维护，与已有版本不兼容、被植入恶意程序等意外情况。  
官方会统一考虑一个改动在所有生态插件造成的影响，并以一个最合理的思路做整体改造，生态包无论是接口还是兼容性都不需要担心，设计思路也会一脉相承
**中等服务范围优势**
- 设计  
分层设计做到折中，即官方还是会维护生态，只不过生态不是必须，可以按需使用。这样兼顾了一些优势
- 概念  
与小服务范围框架一样，对于核心包来说学习成本比较低。
- 维护  
和大框架一样虽然生态不强求，但是官方还是要持续维护，因此维护成本高的问题依然存在。
- 生态
虽然生态是按需的，但毕竟中等服务范围的框架官方会实现一套标准生态插件，极大影响社区生态发展空间，导致“非官方插件”没人愿意做，因此生态多样性会差一些。
## 渲染机制
渲染机制主要在JSX vs Template之间，不同的表达方式之间还是存在一些本质的区别  
**JSX的优势**
- 纯JS表达UI  
单这一点就非常重要，满足All in JS的幻想，但是HTML、CSS相比JS来说，模块化能力和灵活性都很弱，都收敛到JS不仅表达繁华似更统一，更重要的是获得了与JS一样模块化、灵活性、TypeScript支持等能力。
- 视图即数据  
将视图看作一种数据，让针对视图的逻辑测试成为可能。  
同时将视图概念泛化了，因为数据是平台无关的，一份描述视图的DSL可以运行在任何平台
**JSX的劣势**
- 开销大  
节点越多，Diff开销就越大
- 动态渲染很难性能优化  
所有DOM节点都是动态生成，无法根据初始状态结构进行安全的优化。相比之下Template模式可以确定那部分属于变量，那部分是固定的，对固定部分的Diff检测都可以跳过。
- 动态调度虽然改善了性能，但依赖更重的运行时  
React ConcurrentMode是一个调度优化器，但实现的逻辑比较复杂，加重了运行时负担。
**Template的优势**
- 原生性能  
由于Template对节点进行直接渲染，因此与原生性能一致
- Runtime更小  
不需要额外优化，运行时代码会小很多 
**Template的劣势**
- 被Template语法约束，无法拓展  
对于Template不支持的只能选择接受，因为除了框架自己，没人能拓展Template的特性。当遇到一些非常动态场景，但Template不支持的情况，只能选择接受，并用比较Hack的方式绕过解决，除此没有其他的方法。
- 模板冗长  
JSX可以利用循环语句或者变量赋值进行模板区块多块复用，但Template模式每次新模板都要一行一行打出来。
- 运行时解析开销或者依赖编译期逻辑  
要么通过编译器预先生成AST，要么运行时动态将Template解析成AST，无论哪种方案都有额外的开销，一种是工程依赖的开销，一种是运行时动态解析的性能开销。  
**VDom + Template的特色**
Vue在Template基础支持了虚拟DOM，因此兼具两者特色  
性能上，在编译时就进行AST解析，减少了运行时解析开销  
功能是，支持模板与JSX两种语法
## 状态机制
- Mutable vs Immutable
- 依赖追踪 vs 脏检查
- 响应式 vs 模拟响应式

## 总结
**框架设计没有银弹**  
与数学公式不同，框架设计甚至整个工程技术设计都没有所谓的真理，实现一个技术目标的众多方案之间也许是平行关系，可以根据维度列出对比，但无法得出总结论孰优孰劣。  
**使用场景不同**  
不同场景决定了对框架诉求不同。  
比如开发非常定制、炫酷的可视化大屏，那么前端开发框架基本也用不上，因为关注点不在项目路由，UI描述，甚至是数据流，而是聚焦在性能，图形渲染等问题。解决这些领域的框架可能是虚幻4、Unity等游戏引擎，但普通的前端开发框架绝不会涉足这种领域，框架一定要确定自己功能范围。  
即使局限在Web领域，也需要考虑是否支持非Web场景，将HTML抽象成一个通用的DSL就可能是一种选择，但非Web领域毕竟不是主打业务领域，在这种业务场景周边生态维护可能就比较少。  
**使用的人不同**
不同的团队对框架的要求不同。  
刚起步的小团队需要保姆式的框架，因为这样最节省人力成本，但是对于规模较大的团队，希望对框架拥有较大定制能力。框架作者可以像Vue一样做出渐进式官方能力增强方案，以满足不同需求的用户，但毕竟也不能将生态完全交给社区。  
遇到更新更酷的框架时，需要冷静思考不只是这个框架带来的收益与花费的迁移成本那个更高，以及团队能否接受这套框架的开发习惯，更需要思考的是这个框架自身做了哪些权衡，如果这些权衡与React、Vue、Angular类似那么仅仅变化了语法或语音的改动其实意义不大

原文: 
[精读《寻找框架设计的平衡点》](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/133.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%AF%BB%E6%89%BE%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B9%B3%E8%A1%A1%E7%82%B9%E3%80%8B.md)
