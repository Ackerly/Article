# React 数据获取与性能优化
**数据获取的分类**  
一般来说可以将 “数据获取” 大致分为两类：初始数据获取 (initial data fetching) 和按需数据获取 (data fetching on demand)。  
按需数据获取，是用户和页面发生交互后再请求数据，以便提高页面的交互体验。所有的自动填充、动态表单和内容搜索都属于这一类数据。在 React 中，通常是在事件的回调函数中请求这些数据。  
初始数据获取，是在打开页面时我们期望立刻能看到数据，我们要在组件出现在屏幕之前拿到这些数据。这些内容对于用户体验比较重要，需要尽快展示出来。在 React 中，通常是在 useEffect (或者 componentDidMount) 中来发起这类数据请求。  
虽然它们在概念上看起来完全不同，但获取数据的核心原则和基本模式是完全相同的。对于大部分人来说，初始数据获取通常是至关重要的。在这一阶段，你的应用程序给用户留下第一印象，要么是 “慢如黄牛” 要么是 “快如闪电”。  

**React 获取数据与类库支持**  
在 React 中要用第三方类库来获取数据吗？这要取决于我们的具体场景，如果我们只是简单的请求一次数据，那么就不需要第三方库支持。在 useEffect 中直接使用 fetch 即可：  
``` 
const Component = () => {
   const [data, setData] = useState();

   useEffect(() => {
     // fetch data
     const dataFetch = async () => {
       const data = await (
         await fetch(
           "https://run.mocky.io/v3/b3bcb9d2-d8e9-43c5-bfb7-0062c85be6f9"
         )
       ).json();

       // set state when the data received
       setState(data);
     };

     dataFetch();
   }, []);

   return <>...</>
 }
```
但是当我们的场景变得复杂时，就会面临一些棘手的问题。错误处理要怎么实现？如何处理多个组件从同一个接口获取数据？这些数据是否要缓存？缓存时间是多久？竞态问题 (race conditions) 要如何处理？如果要从屏幕上删除组件，那该怎么办？应该取消这次请求吗？内存泄漏又要怎么解决？问题诸如此类。  
上面提出的问题并不只是针对于 React，这些是网络请求中数据获取的常见问题。解决这些问题（还有更多）只有两条路：要么重新发明轮子编写大量代码来解决这些问题，要么依靠一些已经存在的成熟类库。  
这些类库，比如 axios，将对一些功能进行抽象和封装，如请求取消等，但是并不提供针对 React 的 API。其他类库，比如 swr，将为我们处理了几乎所有的事情，包括缓存。但本质上，技术的选择在这里并不是关键的。世界尚不存在这样的类库，仅通过自身就能提高应用程序的性能。它们只是让一些事情变得更容易，同时也让另外一些事情变得更困难。  

**React 应用的性能**  
对于一个简单的组件来说，是相对比较直观的：只需要测量渲染的耗时即可。数字越小，组件 “性能” 越好（速度更快）。数据获取属于典型的异步操作，在大型应用中从用户体验角度来看性能，就不是那么直观了。  
假设正在开发一个用来追踪 issue 的应用。页面的左侧是一个 Sidebar 侧边栏，展示了一个链接列表；中间部分是主内容区，它的上半部分是用于展示 issue 的详情区，比如标题、描述等；issue 详情区的下方是评论区。  
假如这个应用程序用下面三种不同的方式来实现：  
1. 展示一个 loading 状态，直至所有数据加载完毕，然后一次性渲染出所有数据。大约花费了 3s
2. 展示一个 loading 状态，侧边栏的数据加载完成后，渲染出侧边栏，然后继续保持 loading 状态，直到中间的内容区域的数据加载完成。侧边栏的需要 1s 的时间完成渲染，其他部分需要 3s 的时间。加到一起，大约花费了 4s  
3. 展示一个 loading 状态，加载完主内容区的 issue 并渲染它，保持 loading 状态并加载侧边栏和评论的数据。侧边栏完成数据请求和渲染之后，继续为评论数据的加载保持 loading 状态。issue 的加载和渲染需要 2s，sidebar 在它之后需要 1s，评论需要额外的 2s 完成渲染。共计花费了 5s

第一种实现方案总共花费 3s，是所有实现方案中最快的。单纯从数字的角度来看，毫无疑问它是胜出的。但是，在 3s 的时间里，它没有为用户呈现任何内容，这段白屏也是所有实现方案中最长的。  
第二种实现方案只用了 1s 就在页面上显示出了一部分内容（Sidebar）。从尽可能快地展示内容的角度来看，它无疑是胜出的。但是，它是所有方案中主内容区耗时最长的。  
第三种实现方案中，首先完成了主内容区的 issue 加载。从主内容区的加载速度来看，它是胜出的。但是，在从左到右的语言中，信息的自然流动方向是从左上到右下。这也是我们通常的阅读方式。这个页面违反了这个这个规则，这带来了最糟糕的用户体验。除此之外，它的加载时间是最长的。  
对于方案的选择，通常取决于我们要向用户传递什么样的信息。把自己当作一个讲故事的人，而页面就是我们要讲述的故事。这个故事中最重要的部分是什么呢？次重要的部分又是什么呢？故事的情节是否连贯呢？你是想拆解成不同的章节讲述呢，还是立刻让用户看到故事的全貌呢？  
只有当你对故事的样子有所了解，才是将故事整合在一起，并尽可能快地优化故事的时候。同理，应用的性能优化也是如此。而让我们解决问题的不是各种类库，不是 Graphql 或 Suspense，而是下面的知识：  
- 数据获取合适的开始时机是什么？
- 在数据获取正在进行时，我们能做些什么？
- 在数据获取完成之后，我们应该做些什么？

原文:  
[React 数据获取与性能优化](https://mp.weixin.qq.com/s/vufI24NCasCT32UQG3A_UQ)
