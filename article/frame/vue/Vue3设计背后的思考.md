# Vue3设计背后的思考
## 为什么重写
### 利用新的语言特性
ES2015的标准化，添加了新的特性和提供像样的支持。其中一些特性可以极大的提高Vue的能力，比如Proxy。Vue的一个核心功能是响应式更新DOM。Vue2通过对象的属性替换成getter和setter来实现这种响应式。转到Proxy后一些限制被解决。比如解决了无法检测新属性增加的问题。但是Proxy是原生属性，无法通过polyfill支持老的浏览器，只能调整框架浏览器支持范围（这是一个巨大不兼容更新），只能通过大的新版本来发布。
### 解决结构问题
维护 Vue 2 的过程中，我们累积了很多问题，并且因为目前的架构限制很难被解决。比如模板编译器实现导致很难支持良好的 source-map 功能。虽然 Vue 2 在技术上可以实现面向非 DOM 平台的高阶渲染器，但需要 folk 代码库并且复制很多代码来实现。在当前代码库中解决这些问题需要进行巨大且有风险的重构，几乎等于重写。隐式地耦合了很多内部模块和放哪儿都不合适的孤岛代码，累积了很多技术债。这使得单独去理解代码中的一部分变得很困难。
## 最初的原型阶段
### 转换到Typescript
使用了 Facebook 的 Flow 类型检查，因为它可以被渐进地添加到已经存在的普通的 ES 项目中。Flow 确实带来了一定程度的帮助，但并没有希望的那么多。它持续的不兼容更新使得升级非常痛苦。并且相比于 Typescript 和 VSCode 的深度整合，它对开发环境的支持并不理想。更多的用户使用TypeScript，但是源码使用另一种类型系统，转换到TypeScript后可以自动生成类型文件，减轻维护的负担。
### 解耦内部模块
采用了 monorepo 的方式通过各个内部模块来组成框架。每个模块都有它们自己的 API，类型定义，和测试。
### 启用RFC过程
Vue 的大规模使用意味着不兼容变更会导致用户巨大的迁移成本以及可能的生态割裂。为了确保用户能够对不兼容变更提供反馈，我们在2019年初启用了 RFC （征求意见）过程。每个 RFC 都会遵循一个模版，模板中有各个区块分别聚焦于动机、设计细节，利弊权衡，以及采用策略。RFC 过程证明了非常有用，它提供了一个思考框架来强制我们全面地考虑一个潜在变更的各个方面。并且允许我们的社区参与设计过程以及提交经过深思熟虑的功能请求。
## 更快更小
重写提供了一个机会通过实验新的渲染策略把性能优化做得更好。
### 突破虚拟 DOM 的瓶颈
Vue提供类似HTML的模板语法，把模板编译成渲染函数返回虚拟DOM树。通过递归比较两个虚拟DOM树中每一个属性，决定需要更新的DOM部分。但更新过程还是引入不必要的CPU开销。在某些情况下特别明显，比如模板有大量的静态内容和少量的动态绑定——却依然要递归整个虚拟 DOM 来确定哪个地方更新了。  
Vue 2 通过跳过静态子树某种程度做了相关的事情，但更进一步的优化因为受限于过于简单的编译器架构而无法实现。在 Vue 3 中重写了编译器，实现了适合的抽象语法树转换过程，允许我们组合转换插件来对编译时做优化。  
编译器和运行时需要一起配合工作：编译器分析模板，生成带有优化相关提示的代码，然后运行时根据这些提示尽可能选择最快的更新路径。主要的优化有：
- 在树层面，没有动态 修改节点结构的模板指令（比如 v-if 和 v-for），节点结构就可以完全静态。所以把结构性指令为切分点把模板分割为嵌套的“区块”。每个区块动态编订可以再扁平的数组中被跟踪。通过数量级程度地减少数遍历避免大量的虚拟DOM开销  
- 编译器尽可能地检测模板中的静态节点，子树，甚至数据对象，并在生成的代码中把它们提升到渲染函数之外。避免了在每次渲染中重复创建这些对象，极大改善了内存使用，降低了垃圾回收的频率。  
- 在元素层面，编译器针对每个有动态绑定的元素，根据它需要实现的更新类型，生成相应的优化标识。举个例子，一个带有动态 class 绑定和一些静态属性的元素会收到一个标识表示只需要检查 class 更新就可以了。运行时会根据这些提示选择最快的更新路径。
## 减少打包体积
用户在构建时应该能够舍弃掉框架中没有使用到的功能的相关代码——也就是所谓的“tree shaking”——只为他们需要的付出开销就可以了。这样就可以发布一些对部分用户有用但不会给其他用户新增负担。  
Vue 3 中，通过把大多数的全局 API 和内部的 helper 作为 ES 模块导出来实现这一点。这样就能允许现代的打包工具对模块的依赖做静态分析，并且舍弃没有使用到的代码。模板编译器同样会生成 tree-shaking 友好的代码，只有模板中实际使用的功能才会在生成的代码中导入相应的 helper。  
框架中的某些部分没办法被 tree-shaken，因为它们对所有类型的应用都是必需的。这些不可或缺的部分的体积叫基准大小。Vue 3 的基准大小大概是 10KB gzipped——比 Vue 2 的一半还少，尽管增加了大量的新功能。
## 解决扩展性需求
通过暴露更底层的响应式和组件生命周期 API 来提供更自由的方式写组件逻辑，也即 Composition API。与设置一长串的选项来定义组件不同，Composition API 允许用户自由地表达，组合，复用带状态的组件逻辑，就像写函数一样，同时提供极佳的 Typescript 支持。




参考:  
[Vue3 设计背后的思考](https://juejin.cn/post/6870627817009184776?content_source_url=https%3A%2F%2Fgithub.com%2Fvue3%2Fvue3-News)
