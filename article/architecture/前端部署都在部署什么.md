# 前端部署都在部署什么
## 问题
- 前端代码从 tsx/jsx 到部署上线被用户访问，中间大致会经历哪些过程？
- 上述过程中分别都有哪些考虑、指标和优化点，以满足复杂的业务需求？
- 可能大部分同学都知道强缓存/协商缓存，那前端各种产物（HTML、JS、CSS、IMAGES 等）应该用什么缓存策略？以及为什么？
    - 若使用协商缓存，但静态资源却不频繁更新，如何避免协商过程的请求浪费？
    - 若使用强缓存，那静态资源如何更新？
- 配套的，前端静态资源应该如何组织？
- 配套的，自动化构建 & 部署过程如何与 CDN 结合？
- 如何避免前端上线，影响未刷新页面的用户？
- 刚上线的版本发现有阻塞性 bug，如何做到秒级回滚，而非再次部署等 20 分钟甚至更久？
- 如何实现一个预发环境，除了前端资源外都是线上环境，将变量控制前端环境内？
- 部署环节如何方便配套做 AB 测试等？
- 如何实现一套前端代码，发布成多套环境产物？
- 如何实现按 feature 发布产物供用户使用，并逐步扩大 feature 灰度，将影响减到最小（即线上同时存在多 feature 产物）？
- CDN 域名突然挂了，如何实现秒级 CDN 降级修补而非再次全部业务重新部署一次？

## 静态资源组织
前端资源由 HTML、JavaScript、CSS三部分组成，静态资源通过 FTP 等软件，上传到 Web 服务器（如 Nginx）某目录，将 Nginx 启动做简单配置即可让用户访问。
### 利用缓存
每次访问都会请求 foo.css, bar.css 等静态文件，即使该文件并无变更。对带宽甚是浪费，对页面首屏性能等也有影响。于是在网络带宽紧张的互联网早期，计算机先贤们在 HTTP 协议上制定了多种缓存策略。
> 浏览器缓存：浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。

#### 协商缓存
向服务器发送请求，服务器会根据这个请求的 Request Header 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 Response Header 通知浏览器从缓存中读取资源；  
协商缓存一般可在服务端通过设置 Last-Modifed、ETag 等 ResponseHeader 实现。304 状态码，表示资源未发生变更，可使用浏览器缓存。
#### 强缓存
浏览器不会向服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK。除非缓存时间过期，不然会一直使用本地缓存  
> From DiskCache：从硬盘中读取  
From MemoryCache：从内存中读取，速度最快。  
在服务端通过设置 Cache-Control:max-age、Expires 等 ResponseHeader 实现

#### 缓存更新问题
鉴于页面（index.html）会频繁更新，而静态资源则相对稳定。所以，我们能推断出的一种缓存策略是 index.html 适合走协商缓存，相对稳定 & 不常更新的静态资源（JS、CSS、IMAGES） 等应该消灭协商请求，使用强缓存。  
然而问题很快就来了，都不让浏览器发请求，但缓存还未到期我们发现有 bug，想更新 foo.css 怎么办？  
给资源加版本号！比如通过 query 加版本号，每次上线统一改版本号就搞定了。  
统一加版本号的优点是简单粗暴快捷，但缺点则是：假如我们只想更新 foo.css，但 bar.css 缓存也失效了，又造成了带宽的浪费。  
将文件内容与版本号（URL）绑定，当文件内容发生变更时才变更版本号（URL），这样就能实现每个文件精确的缓存控制。  
什么东西与文件内容相关呢？ 消息摘要算法 ，对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据。现在，我们把 URL 改成带文件摘要信息的：  
这种方式为 query-hash，后续发版上线时，只有被变更文件的 URL 会更新，实现了精确的缓存控制  
#### 覆盖式发布引发的问题
假如我们就按上述部署方案就上了线，很快就会 Fatal 满天飞，每次更新上线都可能会出现灾难。
某次更新时，更改了 foo.css 样式，此时会将 HTML 中的foo.css url更新为最新的 hash，并将服务器中存储的 foo.css & index.html 文件覆盖为最新（V2版本），看似HTML和静态资源都对应更新了，但是没有考虑极端情况。那就是：
- 先部署静态资源，部署期间访问时，会出现V1版本HTML访问到V2版本新静态资源，并按V1-hash缓存起来。  
    1. 用户本地有缓存，此时无影响可正常访问
    2. 用户本地无缓存，则会将V2版本静态资源加载并按V1版本 hash 缓存起来。用户报错。当V2版本HTML部署完成后，用户再次访问时恢复。
- 先部署HTML，部署期间访问时，会出现V2版本HTML访问到V1版本旧静态资源，并按V2-hash缓存起来。  
V2 版本HTML，会将V1版本静态资源按V2版本Hash缓存起来。此时页面会出错，且缓存过期之前会持续报错。直到用户手动清除缓存，或者缓存过期，或者将来发布V3版本更新静态资源版本。否则用户会持续出错。  

静态资源只有一份，每次发布时都是覆盖式发布，导致页面与静态资源出现匹配错误的情况！解决问题方案也极其简单，使用非覆盖式发布，一种简单的改造方式是将文件摘要（hash）放置到URL 中，即将 query-hash 改为 name-hash。
每次部署时先全量部署静态资源，再灰度部署页面，就能比较完美的解决了缓存的问题。（服务器上会存在多份 foo.[$hash].css 文件）
#### 与 CDN 结合
随着时间推移，非覆盖部署导致文件逐渐增加多，硬盘逐渐吃紧。而且将文件存储在 Nginx Web服务器内某目录下，深度的将 Nginx、网站、部署过程等强耦合在一起，无法使用 CDN 技术。  
那如何将 CDN 与 Nginx 等 Web 服务器结合呢？  
答案是将静态资源部署到 CDN 上，再将 Nginx 上的流量转发到 CDN 上，这种技术我们称之为『反向代理』。
总体部署方案需要进一步做三步改造：
1. 构建时依据环境变量，将 HTML 中的静态资源地址加上 CDN 域名。
2. 构建完成后将静态资源上传到 CDN 
3. 配置 Nginx 的反向代理，将静态资源流量转发到 CDN

第 1、2 条涉及构建过程调整，以 Webpack 为例，我们需要做以下配置改造：
``` 
a.  配置 `output` 为 `content-hash` & `publicPath`  
b.  配置 `Webpack-HTML-Plugin`
```
``` 
// webpack.config.js
const CDN_HOST = process.env.CDN_HOST;// CDN 域名
const CDN_PATH = process.env.CDN_PATH; // CDN 路径
const ENV = process.env.ENV; // 当前的环境等等
const VERSION = process.env.VERSION; // 当前发布的版本

const getPublicPath = () => {
    // Some code here
    return `${CDN_HOST}/${CDN_PATH}/${ENV}/`;// 依据 ENV 等动态构造 publicPath
}

const publicPath = process.env.NODE_ENV === 'production' ? getPublicPath() : '.';

module.exports = {
    output: {
        filename: 'bundle.[name][contenthash:8].js',
        publicPath,
    },
    plugins: [
        new HtmlWebpackPlugin()
    ]
}
```
备注1：我们往往会将一套代码部署到多套前端环境，还需要在构建时注入当前部署相关环境变量（如 staging、prod、dev、pre等），以便动态构建 publicPath。  
备注 2：这里动态构造的 publicPath 里，严格的将产物按环境 + 发布版本做了隔离 & 收敛。  
某业务前端曾将所有环境的静态资源放到一起，以Hash做区分。但疑似出现了文件名 + hash 冲突，但文件内容不一样，导致了线上事故。故墙裂建议严格对产物做物理隔离。  
备注 3：使用 contenthash 时，往往会增加一个小模块后，整体文件的 hash 都发生变化，原因为Webpack 的 module.id 默认基于解析顺序自增，从而引发缓存失效。具体可通过设置 optimization.moduleIds 设置为 'deterministic' 。  
上传 CDN 源站往往通过 CLI 调用各种客户端工具上传，此时要注意的是上传 CDN 依赖配置鉴权信息（如 文件存储的 Bucket Name/accessKey、ftp的账号密码）。这些鉴权信息不能直接写代码里，否则可能会有事故风险  
### 静态资源组织总结
1. 为了最大程度利用缓存，将页面入口(HTML)设置为协商缓存，将 JavaScript、CSS 等静态资源设置为永久强缓存。
2. 为了解决强缓存更新问题，将文件摘要（hash）作为资源路径(URL)构成的一部分。
3. 为了解决覆盖式发布引发的问题，采用 name-hash 而非 query-hash 的组织方式，具体需要配置 Wbpack 的 output.filename 为 contenthash 。
4. 为了解决 Nginx 目录存储过大 + 结合 CDN 提升访问速度，采用了 Nginx 反向代理+ 将静态资源上传到 CDN。
5. 为了上传 CDN，需要按环境动态构造 publicPath + 按环境构造 CDN 上传目录并上传。
6. 为了动态构造 publicPath 并且随构建过程插入到 HTML 中，采用 Webpack-HTML-Plugin 等插件，将编译好的带 hash + publicPath 的静态资源插入到 HTML 中。
7. 为了保证上传 CDN 的安全，我们需要一种机制管控上传 CDN 秘钥，而非简单的将秘钥写到代码 / Dockerfile 等明文文件中。

## 自动化构建
每次构建时需要进行的骤
- 拉取远程仓库
- 切换到 XX 分支
- 代码安全检查（非必选）、单元测试等等
- 安装 npm/yarn 依赖
    - 设置 node 版本
    - 设置 npm/yarn 源
    - 安装依赖等
- 执行编译 & 构建
- 产物检查（比如检测打包后 JS 文件 / 图片大小、产物是否安全等，保证产物质量，非必选）
- 人工卡点（非必选，如必须 Leader 审批通过才能继续）
- 打包上传 CDN
- 自动化测试（非必选，e2e）
- 配套剩余其他步骤
- 通知构建完成

迎面而来的问题有：
- 在什么环境执行构建？
- 如何保证每次构建部署环境相同？
- 由谁触发构建？
- 如何管理前面所述上传 CDN 等密钥（不增加成本、保证安全、保证构建上传可靠性）？
- 如何自动化触发构建 & 自动化执行上述步骤？

解决方案：
- 保证环境一致性：Docker
- 按流程构建：Jenkins
- 自动化构建触发：Gitlab webhook 通知
- 开始构建通知：依赖账号体系打通+ Gitlab Webhook
- 构建完成通知：依赖账号体系打通

## 前端发布服务 - 预发环境、版本管理（秒级回滚）、小流量、灰度、AB测试
假定我们静态资源组织完成，也搞定了自动化构建部署，也配好了 Nginx 的反向代理，我们的网站终于第一次上线了。  
但第二次第三次上线怎么办？直接发到生产环境做回归测试的风险极大，但又不能本地部署前端测试环境去连接后端生产库（可以想想为什么），所以我们需要一个预发（Pre）环境，除了非测试人员访问不到之外，其他所有环节都和生产环境保持一致！
假如我们某个功能是元旦零点发布，跨年时守在服务器面前点发布？万一 npm 抽风拉取依赖失败导致构建失败，或者上线后发现有bug，  
随着时间推移大家前端项目越积越大，node_modules 越来越大，构建的时间往往会超过二十分钟甚至更久。某天某次我们新上线了功能后，却发现有致命阻塞性 bug，收款后自动退款 1.5 倍！想立即回滚版本？那就且等着，大眼瞪小眼的等它慢慢编译吧。这个时候才真的是时间就是金钱，再编译慢点公司就破产啦。
有没有一种办法，能在发现问题后，立即将版本回滚呢？并且这个回滚操作，回滚的也不应该登陆服务器去做操作
此时遇到第二个需求，版本管理功能。 即可提前将静态资源上线，也需要保留每个历史版本，并且能实现瞬间切换版本，且切换过程不应该登陆服务器操作
假定 PM 对功能不断优化，想先灰度一部分用户，或者想做一些 AB 测试，比如给广东用户推广福建美食，给重庆用户推广钵钵鸡。  
此时我们有两种方案，方案一是将把钵钵鸡和福建美食都打包到一份代码产物里，再在运行时根据地域做切换。但很快你的代码产物里就有钵钵鸡冷锅串串热锅串串老妈兔头跷脚牛肉狼牙土豆以及福建美食等等  
方案二是我们将热锅串串和冷锅串串分开打包，让热锅不犯冷锅。再设计一些机制，比如携带了香蕉糖果（cookie）的同学给跷脚牛肉锅，讲港东话的同学福建美食锅，四川地域的同学随机给火锅干锅汤锅鱼火锅。  
这种机制是极其多变的，大概率朝令夕改。难道我们每次想调整干锅、鱼火锅的比例，就要登陆服务器做调整？某天干锅卖完了但又没带电脑回家怎么办  
此时遇到第三个需求，随时调整的小流量测试、AB-Test测试、灰度上线等等功能。
### 静态资源的加工
通过 BFF 层或通过后端直出 HTML，并且在过程中注入若干信息，如 userInfo、用户权限信息、灰度信息等等，从而大幅降低前端登陆研发成本 & 降低首屏耗时。下面是后端直出 HTML 的一种简要流程： 
前端构建出的 HTML 包含若干模板变量，后端收到请求后，通过各种 Proxy 层将 Cookie 转换成用户信息，再按依据版本配置从 CDN 加载 index.html, 并使用模板引擎等方式将模板变量替换为用户信息，最终吐回给浏览器的则是已经包含用户信息的 HTML 了
### Pre 环境、灰度上线的常见实现
通过一定的机制，让特定用户访问特定静态资源版本，从而达到访问Pre/灰度上线的能力。
#### Nginx 层动态转发
一种常见的 Pre 机制是静态资源部署多个版本后，开发者的通过 ModHeader 等浏览器插件，在请求中携带特定 Header（如xx-env=pre），在 Nginx 层消费该 Header 并动态转发到对应环境的静态资源上，实现访问 Pre 环境目的。此时，除静态资源为特定版本外，所有环境都是生产环境，可以将变量范围控制在最小。  
该方案优点为配置简单高效，适用于工程师。  
缺点为每个用户都需要手动配置，不适用于移动端，且无法让特定用户被动精确访问某版本，比如 PM、KP 用户来配置 Header 成本过高。
可以在 Nginx 层按一些其他规则处理，实现灰度上线的能力。  
通过一定随机数 rewrite，达到小范围随机灰度。  
获取 ua 并 rewrite，达到按浏览器定向灰度。  
通过 Nginx GeoIP 获取地域信息，达到按地域灰度。  
上述灰度方案配置复杂，而灰度比例 / 范围往往会配置较多，每次上线都需要运维登陆生产服务器修改，较容易出各种事故
#### 动态配置 + 服务端转发
 Pre 环境或灰度往往需要精确定位某些特定人群，如给特定PM、HR、远端报错的特定用户、KP用户 甚至给某个部门开 Pre环境等。上述同学工程背景相对缺失 / 较忙 / 通过移动端访问，此时通过修改 Header 的方式不再适用。  
 为了能随时随地调整灰度 / Pre 策略，而非依赖调整代码发版上线，此时引入配置中心的概念。
 > 一般是独立的平台 / SDK，提供动态配置管理的解决方案，提供功能有配置管理、版本管理、权限管理、灰度发布等等。后端应用通过接口消费，故配置中心和后端解耦，可以随时修改调整配置而非重新发版。配置中心一般是配置一个 JSON 对象。配置中心JSON对象人工维护容易引发问题，故增加机器人来降低出错几率。

主要流程为：
1. 前端部署多个版本静态资源到 CDN 上。
2. 后端收到请求后，通过各种 Proxy 层将 Cookie 转换成用户信息。
3. 后端读取配置中心数据，依据用户信息判断给用户访问什么环境，加载具体环境 index.html
4. 后端返回给浏览器加工后的 index.html
5. 若需添加具体 KP 等同学到 Pre 名单，攻城狮同学只需调用机器人/Bot 等，修改配置中心，即可生效。

该方案优点：可以随时调整，不用后端发版，移动端也可生效。  
该方案缺点：
1. 和服务端强绑定（要求用户信息，在所难免）。
2. 每次都需要从 CDN 加载 HTML， 有一定性能浪费。但若缓存 HTML，发版环节还要通知服务端，总体增加复杂度。
3. 若考虑 CDN 故障，服务端做 CDN 降级会增加复杂度。
4. 版本管理 / 小流量等为通用需求，而该方案每个后端应用都需要开发或接入。
5. 常见的配置中心又一般为 JSON 配置，比较简陋，和发版的多环境无法关联，依赖人为配置，有出错的风险（如发版 v1.2501，配置中心手动配置时手误改成了v1.2051）。
#### 前端发布服务实现与设计
通过源码做版本管理灵活性较差，无法做到一键 &秒级切换版本，不满足商业化环境多变 & 复杂的需要。  
如何进行版本管理呢？答案是对构建产物进行深层次加工 & 管理。
与此同时，版本管理/小流量是前端部署的常见公共业务需求，应该和业务后端服务脱离，这里提出一个新的公共服务，纯用于前端部署相关，此处将之称为 Page Server，用于具体的 index.html 文件管理 & 承接 Nginx 流量或业务后端流量等。  

参考：
[2021 年当我们聊前端部署时，我们在聊什么](https://juejin.cn/post/7017710911443959839)
