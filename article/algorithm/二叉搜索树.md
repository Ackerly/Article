# 二叉搜索树
二叉搜索树的特性是，任何一个节点的值：
- 都大于左子树任意节点
- 都小于右子树任意节点

**二叉搜索树的最近公共祖先**  
> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。  
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

第一个判断条件是相同的，即当前节点值等于 p 或 q 任意一个，则当前节点就是其最近公共祖先。  
如果不是呢？同时考虑二叉搜索树与公共祖先的特性可以发现：
1. 如果 p q 两个节点分别位于当前节点的左 or 右边，则当前节点符合要求
2. 如果 p q 值一个大于，一个小于当前节点，说明 p q 分布在当前节点左右两侧

基于以上考虑，可以仅通过值大小来判断  
**验证二叉搜索树**  
> 给定一个二叉树，判断其是否是一个有效的二叉搜索树  
假设一个二叉搜索树具有如下特征:  
> - 节点的左子树只包含小于当前节点的数。
> - 节点的右子树只包含大于当前节点的数。
> - 所有左子树和右子树自身必须也是二叉搜索树。

二叉搜索树最重要的就是对节点值的限制，如果能正确卡住每个节点的值，就可以判断了。  
如何判断节点值是否正确呢？可以用递归的方式倒推，即从根节点开始，假设根节点值为 x，那么左树节点的值就必须小于x，再往左，那么值就要小于（假设第一个左节点值为 x1） x1，右树也是一样判断，因此就可以写出答案：  
``` 
function isValidBST(node: TreeNode, min = -Infinity, max = Infinity) {
  if (node === null) return true
  // 判断值范围是否合理
  if (node.val < min || node.val > max) return false
  // 继续递归，并且根据二叉搜索树特定，进一步缩小最大、最小值的锁定范围
  return 
    // 左子树值 max 为当前节点值
    isValidBST(node.left, min, node.val) &&
    // 右子树值 min 为当前节点值
    isValidBST(node.right, node.val, max) &&
}
```
**删除二叉搜索树中的节点**  
> 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。  
一般来说，删除节点可分为两个步骤：
> 1. 首先找到需要删除的节点；
> 2. 如果找到了，删除它

要删除二叉搜索树的节点，找到节点本身并不难，因为如果值小了，就从左子树找；如果值大了，就从右子树找，这本身查找起来是非常简单的。难点在于，如何保证删除元素后，这棵树还是一颗二叉搜索树？  
假设删除的是叶子结点，很显然，二叉搜索树任意子树都是二叉搜索树，又没有破坏其他节点的关系，因此直接删除就行了，最简单。  
如果删除的不是叶子结点，那么谁来 “上位” 代替这个节点呢？题目要求复杂度为 O(h) 显然不能重新构造，需要仔细考虑。  
 假设删除的节点存在右节点，那么肯定从右节点找到一个代替值移上来，找谁呢？找右节点的最小值呀，最小值很好找的，找完代替后，相当于问题转移为删除这个最小值节点，递归就完事了。  
设删除的节点存在左节点，但是没有右节点，那就从左节点找一个最大的替换掉，同理递归删除找到的节点。  
**不同的二叉搜索树**  
> 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数

这道题重点在于动态规划思维 + 笛卡尔积组合的思维。  
需要将所有可能性想象为确定了根节点后，左右子树到底有几种组合方式？  
举个例子，假设 n=10，那么这 10 个节点，假设我取第 3 个节点为根节点，那么左子树有 2 个节点，右子树有 7 个节点，这种组合情况就有 DP(2) * DP(7) 这么多，假设 DP(n) 表示 n 个节点能组成任意二叉搜索树的数量。  
这仅是第 3 个节点为根节点的情况，实际上每个节点作为根节点都是不同的树（轴对称也算不同的），那么我们就要从第 1 个节点计算到第 n 个节点。  
考虑特殊情况 DP(0)=1 DP(1)=1，所以：  
``` 
function numTrees(n: number) {
  const dp: number[] = [1, 1]

  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] += dp[j - 1] * dp[i - j]
    }
  }

  return dp[n]
}
```
**二叉搜索树的第 K 大节点**  
> 给定一棵二叉搜索树，请找出其中第 k 大的节点。

二叉搜索树的中序遍历是从小到大的，因此只要倒序中序遍历，就可以找到第 k 大的节点。即右、根、左


原文: 
[精读《算法 - 二叉搜索树》](https://github.com/ascoders/weekly/blob/master/%E7%AE%97%E6%B3%95/203.%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%AE%97%E6%B3%95%20-%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%8B.md)
