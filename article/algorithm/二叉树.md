# 二叉树
二叉树其实是链表的升级版，即链表同时拥有两个 Next 指针，就变成了二叉树。二叉树可以根据一些特性，比如搜索二叉树，将查找的时间复杂度降低为 logn，而且堆这种数据结构，也是一种特殊的二叉树，可以以 O(1) 的时间复杂度查找最大值或者最小值。所以二叉树的变种很多，都可以很好的解决具体场景的问题。  
二叉树的三种遍历策略，分别是：前序遍历、中序遍历、后序遍历，这些都属于深度优先遍历。
所谓前中后，就是访问节点值在什么时机，其余时机按先左后右访问子节点。比如前序遍历，就是先访问值，再访问左右；后续遍历就是先访问左右，再访问值；中序遍历就是左，值，右。   
用递归方式遍历树非常简单：  
``` 
function visitTree(node: TreeNode) {
  // 三选一：前序遍历
  // console.log(node.val)
  visitTree(node.left)
  // 三选一：中序遍历
  // console.log(node.val)
  visitTree(node.right)
  // 三选一：后序遍历
  // console.log(node.val)
}
```
**重建二叉树**  
> 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。   
例如  
前序遍历 preorder = [3,9,20,15,7]  
中序遍历 inorder = [9,3,15,20,7]

前序遍历第一个访问的一定是根节点，因此 3 一定是根节点，然后在中序遍历找到 3，这样左边就是所有左子树的中序遍历结果，右边就是所有右子树的中序遍历结果，只要再找到左子树的前序遍历结果与右子树的前序遍历结果，就可以递归了，终止条件是左或右子树只有一个值，那样就代表叶子节点。  
那么怎么找左右子树的前序遍历呢？
由于前序遍历优先访问左子树，因此我们数一下中序遍历中，3 左边的数量，只有一个 9，那么我们从前序遍历的 3,9,20,15,7 在 3 之后推一位，那么 9 就是左子树前序遍历结果，9 后面的 20,15,7 就是右子树的前序遍历结果。  
**从上到下打印二叉树**  
> 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行

这道题要求从左到右顺序打印，完全遵循广度优先遍历，可以在二叉树递归时，先不要急着读取值，而是按照左、中、右，遇到左右子树节点，就推入栈的末尾，利用 while 语句不断循环，直到栈空为止。  
如果题目要求倒序打印，你就可以以 右、中、左 的顺序进行处理。  
**二叉树的深度**  
> 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

由于二叉树有多种分支，在遍历前，我们并不知道哪条路线是最深的，所以必须利用递归尝试。  
可以转换一下思路，用函数式语义方式来理解。假设有这样一个函数 deep 来求二叉树深度，那么这个函数内容是什么呢？二叉树只可能存在左右子树，所以 deep 必然是左右子树的最大深度的最大值 +1（它自己）。  
求左右子树深度可以复用 deep 函数形成递归，只需要考虑边界情况，即访问节点不存在时，返回深度 0 即可，因此代码如下：  
``` 
function deep(node: TreeNode) {
  if (!node) return 0
  return Math.max(deep(node.left), deep(node.right)) + 1
}
```
**平衡二叉树**  
> 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过 1，那么它就是一棵平衡二叉树。

设函数 isBalance 就是答案函数，那么一个平衡二叉树的特征，必然是其左右子树也是平衡的，所以可以写成：
``` 
function isBalance(node: TreeNode) {
  if (root == null) return true
  return isBalance(node.left) && isBalance(node.right)
}
```
左右子树平衡还不够啊，万一左右子树之间深度相差超过 1 就坏了，所以还要求一下左右子树的深度，我们复用上题的函数 deep，整理一下如下：  
``` 
function isBalance(node: TreeNode) {
  if (root == null) return true
  return isBalance(root.left) && isBalance(root.right) &&
    Math.abs(deep(root.left) - deep(root.right)) < 2
}
```
**对称的二叉树**  
> 实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的

一颗二叉树的镜像比较特殊，比如最左节点与最右节点互为镜像，但它们的父节点并不相同，因此 isSymmetric(tree)这样的参数是无法子递归的，必须拆解为左右子树作为参数，让它们进行相等判断，在传参时，将父级不同，但互为镜像的左右节点传入即可。  
写一个函数 isSymmetricNew(left, right)，将 left.left 与 right.right 对比，将 left.right 与 right.left 对比即可。  
**二叉树的镜像**  
> 请完成一个函数，输入一个二叉树，该函数输出它的镜像。

判断镜像比较容易，但构造镜像就要想一想了：
``` 
例如输入：
     4
   /   \
  2     7
 / \   / \
1   3 6   9

镜像输出：
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```
镜像可以理解为左右子树互换，同时 其各子树的左右子树再递归互换，这就构成了一个递归：  
``` 
function mirrorTree(node: TreeNode) {
  if (node === null) return null

  const left = mirrorTree(node.left)
  const right = mirrorTree(node.right)
  node.left = right
  node.right = left
  return node
}
```
从下到上，因此先生成递归好的左右子树，再进行当前节点的互换，最后返回根节点即可。  
**二叉树的最近公共祖先**  
> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先

先考虑特殊情况：如果任意节点等于当前节点，那么当前节点一定就是最近公共祖先，因为另一个节点一定在其子节点中。  
利用递归思想思考，假设利用 lowestCommonAncestor 函数分别找到左右子节点的最近公共祖先会怎样？
``` 
function lowestCommonAncestor(node, a, b) {
  const left = lowestCommonAncestor(node.left)
  const right = lowestCommonAncestor(node.right)
}
```
左右节点都找不到，说明只可能当前节点是最近公共子节点:  
``` 
if (!left && !right) return node
```
如果左节点找不到，则右节点就是答案，否则相反：
``` 
if (!left) return right
return left
```
**二叉树的右视图**  
> 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

用广度优先算法遍历时，对于每一层，都找到最后一个节点打印，并且按顺序打印就是最终答案。
**完全二叉树的节点个数**  
> 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。  
完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1 ~ 2^h 个节点

用递归解决这道题的话，关键要分几种情况探讨完全二叉树。  
由于最底层可能没有填满，但最底层一定有节点，而且是按照从左到右填的，那么递归遍历左节点就可以获取树的最大深度，通过最大深度可以快速计算出节点个树，前提是二叉树必须是满的。  
最底层节点可能不满，那怎么办呢？分情况即可，首先，如果一直按照 node.right....right 递归获得右侧节点深度，发现和最大深度相同，那么就是一个满二叉树，直接计算出结果即可。  
 node.right...left 的深度如果等于最大深度，说明 node.left 也就是左子树是个满二叉树，可以通过数学公式 2^n-1 快速算出节点个树。  
 如果不等于最大深度呢？则说明右子树深度减 1 是满二叉树，也可以通过数学公式快速计算节点个数，再通过递归计算另一边即可。

原文:  
[精读《算法 - 二叉树》](https://github.com/ascoders/weekly/blob/master/%E7%AE%97%E6%B3%95/201.%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%AE%97%E6%B3%95%20-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%8B.md)
