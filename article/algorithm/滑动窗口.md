# 滑动窗口
滑动窗口使用双指针解决问题，所以一般也叫双指针算法，因为两个指针间形成一个窗口。  、
什么情况适合用双指针呢？一般双指针是暴力算法的优化版，所以：  
- 如果题目较为简单，且是数组或链表问题，往往可以尝试双指针是否可解
- 如果数组存在规律，可以尝试双指针
- 如果链表问题限制较多，比如要求 O(1) 空间复杂度解决，也许只有双指针可解

当一个问题比较有规律，或者较为简单，或较为巧妙时，可以尝试双指针（滑动窗口）解法。

## 举例
**两数之和**  
> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
  你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
  
暴力解法就是穷举所有两数之和，发现和为 target 结束，显然这种做法有点慢  
由于可以用空间换时间，又只有两个数，我们可以对题目进行转化，即通过一次遍历，将 nums 每一项都减去 target，然后找到后面任意一项值为前面的结果，即表示它们和为 target。  
可以用哈希表 map 加速查询，即将每一项 target - num 作为 key，如果后面任何一个 num 作为 key 可以在 map 中找到，则得解，且上一个数的原始值可以存在 map 的 value 中。这要仅需遍历一次，时间复杂度为 O(n)。  
这道题是单指针，即只有一个指针在数组中移动，并配合哈希表快速求解。对于稍微复杂的问题，单指针就不够了，需要用双指针解决（一般来说不会用到三或以上指针），那复杂点的题目就是三数之和了。  
**三数之和**  
> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组

由于超过了两个数，所以不能像双指针一样求解了，因为即便用了哈希表存储，也会在遍历时遇到 “两数之和” 的问题，而哈希表方案无法继续嵌套使用，即无法进一步降低复杂度。  
为了降低时间复杂度，希望只遍历一次数组，这就需要数组满足一定条件才能用滑动窗口，所以对数组进行排序，使用快排的时间复杂度为 O(nlogn)，时间复杂度已超出两数之和，不过因为题目复杂，这个牺牲是无法避免的。  
假设从小到大排序，那我们就拿到一个递增数组了，此时经典滑动窗口方法就可用了！怎么滑动呢？首先创建两个指针，分别叫 left 与 right，通过不断修改 left 与 right，让它们在数组间滑动，这个窗口大小就是符合题目要求的，当滑动完毕时，返回所有满足条件的窗口即可，记录其实很简单，只要在滑动过程中记录一下就行。  
首先排除异常值，即数组长度过小，然后对于常规情况，拿一个全局变量存储当前窗口数的和，这样 right + 1 只要累加 nums[right+1]，left + 1 只要减nums[left] 即可快速拿到求和。  
由于需要考虑所有情况，所以需要一次数组遍历，对于每次遍历的起始点 i，如果 nums[i] > 0 则直接跳过，因为数组排序后是递增的，后面的和只会永远大于 0；否则进行窗口滑动，先形成三个点 [i, i+1, n-1]，这样保持 i 不动，不断包夹后两个数字即可，只要它们的和大于 0，就将第三个点左移（数字会变小），否则将第二个点右移（数字会变大），其实第二个和第三个数就是滑动窗口。  
这样的话时间复杂度是 O(n²)，因为存在两次遍历，忽略快排较小的时间复杂度。  
**四数之和**   
首先还是排序，然后双重递归，即确定前两个数不变，不断包夹后两个数，后两个数就是 i+1 和 n-1，算法和三数之和一样，所以最终时间复杂度为 O(n³)。  
为什么没有更优的方法呢？可能因为：
- 无论几数之和，快排一次时间复杂度都是固定的，所以沿用三数之和的方案其实占了排序算法便宜
- 滑动窗口只能用两个指针进行移动，而没有三指针但又保持时间复杂度不变的窗口滑动算法存在

所以对于 N 数之和，通过排序付出了 O(nlogn) 时间复杂度之后，可以用滑动窗口，将 2 个数时间复杂度优化为 O(n)，所以整体时间复杂度就是 O(N - 2 + 1 个 n)，即 O(N-1 个 n)，而最小的时间复杂度 O(n²) 比 O(nlogn) 大，所以总是忽略快排的时间复杂度，所以三数之和时间复杂度是 O(n²)，四数之和时间复杂度为 O(n³)，依此类推。  
从最简单的两数之和，到三数之和、四数之和，跨入了滑动窗口的门槛，本质上是利用排序后数组有序的特性，在不用遍历数组的前提下，可以对窗口进行滑动，这是滑动窗口算法的核心思想  
**无重复字符的最长子串**  
> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度

由于最长子串是连续的，所以显然可以考虑滑动窗口解法。其实确定了滑动窗口解法后，问题很简单，只要设定 left 和 right，并用一个哈希 Set记录哪些元素存在过，在过程中记录最大长度，并尝试 right 右移，如果右移过程中发现出现重复字符，则 left 右移，直到消除这个重复字符为止。  
为什么用滑动窗口遍历一次就可以做到 不重不漏?因为：  
1. 由于子串是连续的，既然不存在跳跃的情况，只要一次滑动窗口内能包含所有解，就涵盖了所有情况
2. 一次滑动窗口内不包含什么？由于只将 right 右移，且出现重复后尝试将 left 右移到不重复后，right 再继续右移，这忽略了出现重复后， right 左移的情况。

如果 abcd 这四个连续的字符不重复，那么 left 右移后，bcd 也显然不重复，所以如果此时就可以将 right 右移形成 bcda 的窗口继续找下去，而不需要尝试 bc 这种情况，因为这种情况虽然不重复，但一定不是最优解。  
**环形链表**  
> 给定一个链表，判断链表中是否有环

要求空间开销必须是常数，所以不得不考虑快慢指针。快慢指针分别跑，只要相遇则判定为环形链表，否则不是环形链表，且一定有一个指针先走完。  
环形链表问题中，链表不是操场，可能只有某一段是环，也就是跑步慢的人至少要跑到环里，才可能与跑得快人的相遇，但跑得慢的人又不知道哪里开始成环，这就是难点。  
为什么快排用二分法，而不是三分法？为什么每次中间来一刀，可以最快排完？原因是二分可以用最小的 “深度” 将数组切割为最小粒度。那么同理，快慢指针中，慢指针要想被尽快追上，速度可能最好是快指针的一半。  
如果慢指针太慢，可能大部分时间都在进入环形之前的位置转悠，快指针虽然快，但永远在环里跑，所以总是无法遇到慢指针。慢指针不能太慢；如果慢指针太快，几乎速度和快指针一样，就像两个运动员都互不相让的争夺第一一样，他们真的想相遇，估计得连续跑几个小时吧，所以慢指针也不能过快。所以这样分析下来，慢指针只能取折中的一半速度。  
但用一半的慢速真的能最快相遇吗？不一定，举一个例子，假设链表是完美环形，一共有 [1,6] 共 6 个节点，那么慢指针一次走 1 步，快指针一次走 2 步，那么一共是 2,3 3,5 4,1 5,3 6,5 1,1 共走 6 步，但如果快指针一次走 3 步呢？一共是 2,4 3,1 4,4 3 步。这么说一般速度不一定最优？其实不是的，计算机在链表寻址时，节点访问的消耗也要考虑进去，后者虽然看上去更快，但其实访问链表 next 的次数更多，对计算机来说，还不如第一种来得快。  
所以准确来说，不是快指针比慢指针快一倍速度，而是慢指针一次走一步，快指针一次走两步最优，因为相遇时，总移动步数最少  
**判断链表中点**  
快指针是慢指针速度 2 倍，当快指针到达尾部，慢指针的位置就是链表中点。  
**链表中倒数第k个节点**  
> 输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点 

只要让慢指针比快指针慢 k 个节点，当快指针到达末尾时，慢指针就指向倒数第 k+1 个节点了。这道题注意一下数数别数错了即可。  
**删除有序数组中的重复项**  
> 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度

假设慢指针是 slow 快指针是 fast,只要让 fast 扫描完全表，把所有不重复的挪到一起就好了，这样时间复杂度是 O(n)，具体做法是：  
1. 让 slow 和 fast 初始都指向 index 0
2. 由于是有序数组，所以就算有重复也一定连在一起，所以可以让 fast 直接往后扫描，只有遇到和 slow 不同的值，才把其和 slow+1 交换，然后 slow 自增，继续递归，直到 fast 走到数组尾部结束。

做完这套操作后，slow 的下标值就是答案。  
**盛最多水的容器**  
> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

定义 left right 两个指针，分别指向 0 与 n-1 即首尾两个位置，此时长度是最大的（柱子间距离是最远的），接下来尝试一下别的柱子，试哪个呢？  
- 较长的那个？如果新的比较短的更短，那么宽度更短了；如果新的比较短的更长，也没用，因为较短的决定了水位。
- 较短的那个？如果新的较长，那么才有机会整体体积更大

移动较短的那个，并每次计算一下体积，最后当两根柱子相遇时结束，过程中最大体积就是全局最大体积。  
**接雨水**  
> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

只有产生了 “凹槽” 才能接到雨水，而凹槽由它两边最高的柱子决定，那什么范围算一段凹槽呢？  
显然凹槽是可以明确分组的，一个凹槽也无法被分割为多个凹槽，就像你看水坑一样，无论有多少，多深的坑在一起，总能一个一个数清楚，所以我们就从左到右开始数。  
用滑动窗口办法，每个窗口就是一个凹槽，那么窗口的起点 left 就是左边第一根柱子，有以下情况：  
- 如果直接相邻的右边柱子更高（或一样高），那从它开始向右看，根本无法接雨水，所以直接抛弃，left++
- 如果直接相邻的右边柱子更矮，那就有产生凹槽的机会
    - 那么继续往右看，如果右边一直都更矮，那也接不到雨水
    - 如果右边出现一个高一些的，就可以接到雨水，那问题是怎么算能接多少，以及找到哪结束呢
        - 只要记录最左边柱子高度，右边柱子的结束判断条件是 “遇到一个与最左边一样高的柱子”，因为一个凹槽能接多少水，取决于最短的柱子。当然，如果右边没有柱子了，虽然比最左边低一点，但只要比最深的高，也算一个结束点。

参考:  
[精读《算法 - 滑动窗口》](https://github.com/ascoders/weekly/blob/master/%E7%AE%97%E6%B3%95/199.%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%AE%97%E6%B3%95%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%8B.md)
