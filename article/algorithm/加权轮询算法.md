# 加权轮询算法
## 核心数据结构
对于每一个被调度的单元来说，抽象出一个叫做Element的类。其中，peer指的是具体的被调度资源，比如IP地址，而weight指的是这个资源的相关权重。  
``` 
public class Element {
    protected String peer;
    protected int weight;

    public Element(String peer, int weight){
        this.peer = peer;
        this.weight = weight;
    }
}
```
具体的调度接口，将直接返回peer的地址
``` 
public interface IWrr {
    String next();
}
```
在代码中直接测试IWrr接口的调度情况。比如，分配7、2、1权重的三个资源，其测试代码如下
``` 
Element[] elements = new Element[]{
	new Element("A", 7),
	new Element("B", 2),
	new Element("C", 1),
};
int count = 10;
IWrr wrr = new WrrSecurityLoopTreeMap(elements);
for (int i = 0; i < count; i++) {
    System.out.print(wrr.next() + ",");
}
System.out.println();
```
## 随机数版本
最简单的方式，就是使用随机数去实现。有在请求量比较大的情况下，随机分布才会向7、2、1的比例逼近。这通常都没什么问题，比如SpringCloud的Robion组件，就是使用随机轮询的方式。  
首先计算总的权重值，记作total，然后每次调用都取total区间的随机数，再依次遍历所有的权重数据。next方法的时间复杂度，在最坏的情况下是O(n)。  
随机调度获取的调用顺序也是随机的，对类似于微服务节点轮询这种场景，比较友好。但对于一些调用量比较小的服务，可能有些节点就会被饿死，毕竟是随机数嘛。  
``` 
public class WrrRnd implements IWrr {
    final int total;
    final Element[] elements;
    final Random random = new SecureRandom();

    public WrrRnd(Element[] elements) {
        this.total = Arrays.stream(elements)
                .mapToInt(ele -> ele.weight)
                .sum();

        this.elements = elements;
    }

    @Override
    public String next() {
        final int n = elements.length;
        int index = n - 1;
        int hit = random.nextInt(total);

        for(int i = 0; i < n; i++){
            if(hit >= 0) {
                hit -= elements[i].weight;
            }else{
                index = i - 1;
                break;
            }
        }

        return elements[index].peer;
    }
}
```

参考:  
[加权轮询算法(wrr)，这个考点，概率有点高！](https://juejin.cn/post/7044767564941459487)
