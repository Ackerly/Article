# 前端算法系统之栈和队列篇  
## 栈&递归
**有效括号**  
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。  
有效字符串需满足：
左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。  
``` 
输入: "()"
输出: true
```
代码实现:  
``` 
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    let stack = [];
    for(let i = 0; i < s.length; i++) {
        let ch = s.charAt(i);
        if(ch == '(' || ch == '[' || ch == '{') 
            stack.push(ch);
        if(!stack.length) return false;
        if(ch == ')' && stack.pop() !== '(') return false;
        if(ch == ']' && stack.pop() !== '[' ) return false;
        if(ch == '}' && stack.pop() !== '{') return false;
    }
    return stack.length === 0;
};
```
**多维数组 flatten**  
将多维数组转化为一维数组  
示例:
``` 
1, [2, [3, [4, 5]]], 6] -> [1, 2, 3, 4, 5, 6]
```
代码实现
``` 
/**
 * @constructor
 * @param {NestedInteger[]} nestedList
 * @return {Integer[]}
 */
let flatten = (nestedList) => {
    let result = [];
    let fn = function (target, ary) {
        for (let i = 0; i < ary.length; i++) {
            let item = ary[i];
            if (Array.isArray(ary[i])) {
                fn(target, item);
            } else {
                target.push(item);
            }
        }
    }
    fn(result, nestedList)
    return result;
}
```
可采用 reduce 的方式, 一行就可以解决，非常简洁。  
``` 
let flatten = (nestedList) =>  nestedList.reduce((pre, cur) => pre.concat(Array.isArray(cur) ? flatten(cur): cur), [])
```
## 二叉树层序遍历
**普通的层次遍历**  
给定一个二叉树，返回其按层次遍历的节点值。（即逐层地，从左到右访问所有节点）。  
示例:  
``` 
   3
  / \
9  20
  /  \
  15   7
```
结果应输出:
``` 
[
  [3],
  [9,20],
  [15,7]
]
```
实现
``` 
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return [];
    let queue = [];
    let res = [];
    let level = 0;
    queue.push(root);
    let temp;
    while(queue.length) {
        res.push([]);
        let size = queue.length;
        // 注意一下: size -- 在层次遍历中是一个非常重要的技巧
        while(size --) {
            // 出队
            let front = queue.shift();
            res[level].push(front.val);
            // 入队
            if(front.left) queue.push(front.left);
            if(front.right) queue.push(front.right);
        }        
        level++;
    }
    return res;
};
```
**二叉树的锯齿形层次遍历**  
给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。  
例如：  
给定二叉树 [3,9,20,null,null,15,7], 输出应如下:
``` 
    3
   / \
  9  20
    /  \
   15   7
```
返回锯齿形层次遍历如下：  
``` 
[
  [3],
  [20,9],
  [15,7]
]
```
代码实现  
``` 
var zigzagLevelOrder = function(root) {
    if(!root) return [];
    let queue = [];
    let res = [];
    let level = 0;
    queue.push(root);
    let temp;
    while(queue.length) {
        res.push([]);
        let size = queue.length;
        while(size --) {
            // 出队
            let front = queue.shift();
            res[level].push(front.val);
            if(front.left) queue.push(front.left);
            if(front.right) queue.push(front.right);
        }  
        // 仅仅增加下面一行代码即可
        if(level % 2) res[level].reverse();      
        level++;
    }
    return res;
};
```
**二叉树的右视图**  
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。  
示例:  
``` 
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```
用广度优先搜索的思想，即用层序遍历的方式,而不是深度优先搜索  
代码实现  
``` 
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    if(!root) return [];
    let queue = [];
    let res = [];
    queue.push(root);
    while(queue.length) {
        res.push(queue[0].val);
        let size = queue.length;
        while(size --) {
            // 一个size的循环就是一层的遍历，在这一层只拿最右边的结点
            let front = queue.shift();
            if(front.right) queue.push(front.right);
            if(front.left) queue.push(front.left);
        }
    }
    return res;
};
```
## 无权图 BFS 遍历
**完全平方数**  
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。  
示例:  
``` 
输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
```
实现  
``` 
/**
 * @param {number} n
 * @return {number}
 */
var numSquares = function(n) {
    let queue = [];
    queue.push([n, 0]);
    while(queue.length) {
        let [num, step] = queue.shift();
        for(let i = 1; ; i ++) {
            let nextNum = num - i * i;
            if(nextNum < 0) break;
            // 还差最后一步就到了，直接返回 step + 1
            if(nextNum == 0) return step + 1;
            queue.push([nextNum, step + 1]);
        }
    }
    // 最后是不需要返回另外的值的，因为 1 也是完全平方数，所有的数都能用 1 来组合
};
```
这个解法从功能上来讲是没有问题的，但是其中隐藏了巨大的性能问题,为什么会出现这样的问题？  
``` 
queue.push([nextNum, step + 1]);
```
只要是大于 0 的数，统统塞进队列。要知道 2 - 1 = 1， 5 - 4 = 1， 9 - 8 = 1 ......这样会重复非常多的 1, 依次类推，也会重复非常多的2,3等等等等。  
大量的重复数字不仅仅消耗了更多的循环次数，同时也造成更加巨大的内存空间压力。  
需要对已经推入队列的数字进行标记，避免重复推入。改善代码如下:  
``` 
var numSquares = function(n) {
    let map = new Map();
    let queue = [];
    queue.push([n, 0]);
    map.set(n, true);
    while(queue.length) {
        let [num, step] = queue.shift();
        for(let i = 1; ; i++) {
            let nextNum = num - i * i;
            if(nextNum < 0) break;
            if(nextNum == 0) return step + 1;
            // nextNum 未被访问过
            if(!map.get(nextNum)){
                queue.push([nextNum, step + 1]);
                // 标记已经访问过
                map.set(nextNum, true);
            }
        }
    }
};
```
**单词接龙**  
给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：  
- 每次转换只能改变一个字母
- 转换过程中的中间单词必须是字典中的单词

说明:  
1. 如果不存在这样的转换序列，返回 0。
2. 所有单词具有相同的长度。
3. 所有单词只由小写字母组成。
4. 字典中不存在重复的单词。
5. 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。

示例:
``` 
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5

解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。
```
通过 BFS 的方式来进行遍历。实现如下:  
``` 
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
    // 两个单词在图中是否相邻
    const isSimilar = (a, b) => {
        let diff = 0
        for(let i = 0; i < a.length; i++) {
            if(a.charAt(i) !== b.charAt(i)) diff++;
            if(diff > 1) return false; 
        }
        return true;
    }
    let queue = [beginWord];
    let index = wordList.indexOf(beginWord);
    if(index !== -1) wordList.splice(index, 1);
    let res = 2;
    while(queue.length) {
        let size = queue.length;
        while(size --) {
            let front = queue.shift();
            for(let i = 0; i < wordList.length; i++) {
                if(!isSimilar(front, wordList[i]))continue;
                // 找到了
                if(wordList[i] === endWord) {
                    return res;
                }
                else {
                    queue.push(wordList[i]);
                }
                // wordList[i]已经成功推入，现在不需要了，删除即可
                // 这一步性能优化，相当关键，不然100%超时
                wordList.splice(i, 1);
                i --;
            }
        }
        // 步数 +1
        res += 1;
    }
    return 0;
};
```
## 实现优先队列
就是一种特殊的队列, 其底层使用堆的结构，使得每次添加或者删除，让队首元素始终是优先级最高的。关于优先级通过什么字段、按照什么样的比较方式来设定，可以由我们自己来决定。要实现优先队列，首先来实现一个堆的结构。  
**堆的说明**  
堆这种数据结构其本质就是一棵二叉树。但是这棵二叉树比较特殊，除了用数组来依次存储各个节点(节点对应的数组下标和层序遍历的序号一致)之外，它需要保证任何一个父节点的优先级大于子节点，这也是它最关键的性质，因为保证了根元素一定是优先级最高的。  
对于siftUp操作，我们试想一下现在有一个正常的堆，满足任何父元素优先级大于子元素，这时候向这个堆的数组末尾又添加了一个元素，那现在可能就不符合堆的结构特点了。那么现在我将新增的节点和其父节点进行比较，如果父节点优先级小于它，则两者交换，不断向上比较直到根节点为止，这样就保证了堆的正确结构。而这样的操作就是siftUp。  
siftDown是与其相反方向的操作，从上到下比较，原理相同，也是为了保证堆的正确结构。  
**实现一个最大堆**  




参考:
[前端算法系统练习: 栈和队列篇](https://mp.weixin.qq.com/s/tWbeOTx0JpiZOD0YaC1P2A)
