# 动态规划
## 动态规划与暴力、回溯算法的区别
动态规划也有分支概念，不用把每条分支尝试到终点，而是在分叉路口根据前面各分支的表现直接推导下一步的最优解。  
动态规划可解决问题需要同时满足以下三个特点：  
1. 存在最优子结构
2. 存在重复子结构
3. 无后效性

### 存在最优子结构
即子问题的最优解可以推导出全局最优解。  
什么是子问题？比如寻路算法中，走完前几步就是相对于走完全程的子问题，必须保证走完全程的最短路径可以通过走完前几步推导出来，才可以用动态规划。  
如何将最优子结构与全局最优解建立上关系？
- 对于爬楼梯问题，由于每层台阶都是由前面台阶爬上来的，因此必然存在一个线性关系推导。
- 如果变成二维平面寻路呢？那么就升级为二维问题，存在两个变量 i,j 与上一步之间关系了。
- 如果是背包问题，同时存在物品数量 i、物品重量 j 和物品质量 k 三个变量呢？那就升级为三位问题，需要寻找三个之间的关系。
### 存在重复子问题
即同一个子问题在不同场景下存在重复计算。  
比如寻路算法中，同样两条路线的计算中，有一段路线是公共的，是计算的必经之路，那么只算一次就好了，当计算下一条路时，遇到这个子路，直接拿第一次计算的缓存即可。典型例子是斐波那契数列，对于 f(3) 与 f(4)，都要计算 f(1) 与 f(2)，因为 f(3) = f(2) + f(1)，而 f(4) = f(3) + f(2) = f(2) + f(1) + f(2)。
这个是动态规划与暴力解法的关键区别，动态规划之所以性能高，是因为 不会对重复子问题进行重复计算，算法上一般通过缓存计算结果或者自底向上迭代的方式解决，但核心是这个场景要存在重复子问题。
### 无后效性  
即前面的选择不会影响后面的游戏规则。
寻路算法中，不会因为前面走了 B 路线而对后面路线产生影响。斐波那契数列因为第 N 项与前面的项是确定关联，没有选择一说，所以也不存在后效性问题。  
## 状态转移方程  
解决动态规划问题的核心就是写出状态转移方程，所谓状态转移，即通过某些之前步骤推导出未来步骤。状态转移方程一般写为 dp(i) = 一系列 dp(j) 的计算，其中 j < i。  
对于复杂问题，难在如何定义 i 的含义，以及下一步状态如何通过之前状态推导。
## 爬楼梯问题
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？（给定 n 是一个正整数）  

首先看是否存在 最优子结构？因为只能往上爬，所以第 i 阶台阶有几种爬方完全取决于前面有几种爬方，而一次只能爬 1 或 2 个台阶，所以第 i 阶台阶只可能从第 i-1 或 i-2 个台阶爬上来的，所以第 i 个台阶的爬法就是 i-1 与 i-2 总爬法之和。  
再看是否存在 存在重复子问题，其实爬楼梯和斐波那契数列类似，最终的状态转移方程是一样的，所以显然存在重复子问题。  
最后看是否 无后效性？由于前面选择一次爬 1 个或 2 个台阶并不会影响总台阶数，也不会影响你下一次能爬的台阶数，所以无后效性。  
爬楼梯的状态转移方程为：
- dp(i) = dp(i-1) + dp(i-2)
- dp(1) = 1
- dp(2) = 2

因为 1、2 阶台阶无法应用通用状态转移方程，所以要特殊枚举。这种枚举思路在代码里其实就是 递归终结条件，也就是作为函数 dp(i) 不能无限递归，当 i 取值为 1 或 2 时直接返回枚举结果（对这道题而言）。所以在写递归时，一定要优先写上递归终结条件。
``` 
function dp(i: number) {
  switch (i) {
    case 1:
      return 1;
    case 2:
      return 2;
    default:
      return dp(i - 1) + dp(i - 2);
  }
}

return dp(n);
```
这样写重复计算了子结构，所以我们不要每次傻傻的执行 dp(i - 1)（因为这样计算了超多重复子问题），我们需要用缓存兜底
``` 
const cache: number[] = [];

function dp(i: number) {
  switch (i) {
    case 1:
      cache[i] = 1;
      break;
    case 2:
      cache[i] = 2;
      break;
    default:
      cache[i] = cache[i - 1] + cache[i - 2];
  }

  return cache[i];
}

// 既然用了缓存，最好子底向上递归，这样前面的缓存才能优先算出来
for (let i = 1; i <= n; i++) {
  dp(i);
}

return cache[n];
```
这只是简单的一维线性缓存，更高级的缓存模式还有 滚动缓存。我们观察发现，空间开销是 O(n)，但每次缓存只用了上两次的值，所以计算到 dp(4) 时，cache[1] 就可以扔掉了，或者说，我们可以滚动利用缓存，让 cache[3] 占用 cache[1] 的空间，那么整体空间复杂度可以降低到 O(1)，具体做法是：
``` 
const cache: [number, number] = [];

function dp(i: number) {
  switch (i) {
    case 1:
      cache[i % 2] = 1;
      break;
    case 2:
      cache[i % 2] = 2;
      break;
    default:
      cache[i % 2] = cache[(i - 1) % 2] + cache[(i - 2) % 2];
  }

  return cache[i % 2];
}

for (let i = 1; i <= n; i++) {
  dp(i);
}

return cache[n % 2];
```
## 最大子序和
> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

首先按照爬楼梯的套路，dp(i) 就表示最大和，由于整数数组可能存在负数，所以越多数相加，和不一定越大。  
接着看 i，对于数组问题，大部分 i 都可以代表以第 i 位结尾的字符串，那么 dp(i) 就表示以第 i 位结尾的字符串的最大和。  
可能你觉得以 i 结尾，就只能是 [0-i] 范围的值，那么 [j-i] 范围的字符串不就被忽略了？其实不然，[j-i] 如果是最大和，也会被包含在 dp(i) 里，因为我们状态转移方程可以选择不连上 dp(i-1)。    
对于 dp(i)，要么和前面连上，要么和前面断掉，所以状态转移方程为：
- dp(i) = dp(i-1) + nums[i] 如果 dp(i-1) > 0。
- dp(i) = nums[i] 如果 dp(i-1) <= 0。

第 i 个状态可以直接由第 i-1 个状态推导出来，既然 dp(i) 是指以第 i 个字符串结尾的最大和，那么 dp(i-1) 就是以第 i-1 个字符串结尾的最大和，而且此时 dp(i-1) 已经算出来了，那么 dp(i) 怎么推导就清楚了：  
因为字符串是连续的，所以 dp(i) 要么是 dp(i-1) + nums[i]，要么就直接是 nums[i]，所以选择哪种，取决于前面的 dp(i-1) 是否是正数，因为以 i 结尾一定包含 nums[i]，所以 nums[i] 不管是正还是负，都一定要带上。 所以容易得知，dp(i-1) 如果是正数就连起来，否则就不连。  
## 最长递增子序列
> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。  
  子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

dp(i) 就表示以第 i 个字符串结尾的最长上升子序列长度。  
由于是不连续的，因此不能只看 dp(i-1) 了，因为 nums[i] 项与 dp(j)（其中 0 <= j < i）组合后都可能达到最大长度，因此需要遍历所有 j，尝试其中最大长度的组合。  
状态转移方程为：dp[i] = max(dp[j]) + 1，其中 0<=j<i 且 num[j]<num[i]。  
## 最长有效括号
> 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

如果 s[i] 是 (，那么不可能组成有效括号，因为最右边一定不闭合，所以考虑 s[i] 为 ) 的场景  
如果 s[i-1] 为 (，那么构成了 ...() 之势，最后两个自成合法闭合，所以只要看前面的即可，即 dp(i-2)  
状态方程:dp(i) = dp(i-1) + dp(i - dp(i-1) - 2) + 2

## 栅栏涂色  
> 有 k 种颜色的涂料和一个包含 n 个栅栏柱的栅栏，每个栅栏柱可以用其中一种颜色进行上色。  
你需要给所有栅栏柱上色，并且保证其中相邻的栅栏柱 最多连续两个 颜色相同。然后，返回所有有效涂色的方案数。

k 和 n 都非常巨大，常规暴力解法甚至普通 DP 都会超时。选择 i 的含义也很重要，    
首先看下递归终止条件。由于最多连续两个颜色相同，因此 dp(0) 与 dp(1) 分别是 k 与 k*k，因为每个栅栏随便刷颜色，自由组合。那么 dp(2) 有三个栅栏，非法情况是三个栅栏全同色，所以用所有可能减掉非法即可，非法场景只有 k 中，所以结果是 k*k*k - k。  
把情况一分为二，考虑 i 与 i-1 颜色相同与不同两种情况考虑。  
如果 i 与 i-1 颜色相同，那么为了合法，i-1 肯定不能与 i-2 颜色相同了，否则就三个同色，这样的话，不管 i-2 是什么颜色，i-1 与 i 都只能少取一种颜色，少取的颜色就是 i-2 的颜色，因此 [i-1,i] 这个区间有 k-1 中取色方案，前面有 dp(i-2) 种取色方案，相乘就是最终方案数：dp(i-2) * (k-1)。  
如果 i 与 i-1 颜色不同，那么第 i 项只有 k-1 种取法，一样也是动态的，因为永远不能和 i-1 颜色相同。最后乘上 dp(i-1) 的取色方案，就是总方案数：dp(i-1) * (k-1)。  
最后总方案数就是两者之和，即 dp(i) = dp(i-2) * (k-1) + dp(i-1) * (k-1)。  
## 编辑距离
> 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。  
你可以对一个单词进行如下三种操作:  
> - 插入一个字符
> - 删除一个字符
> - 替换一个字符

i j 分别表示 word1 与 word2 结尾下标时，最少操作次数。  
那么对于 dp(i,j) 考虑 word1[i] 与 word2[j] 是否相同，最后通过双重递归，先递归 i，在递归内再递归 j，答案就出来了。  
假设最后一个字符相同，即 word1[i] === word2[j] 时，由于最后一个字符不用改就相同了，所以操作次数就等价于考虑到前一个字符，即 dp(i,j) = dp(i-1,j-1)。 
假设最后一个字符不同，那么 最后一步 有三种模式可以得到：  
1. 假设是替换，即 dp(i,j) = dp(i-1,j-1) + 1，因为替换最后一个字符只要一步，并且和前面字符没什么关系，所以前面的最小操作次数直接加过来。
2. 假设是插入，即 word1 插入一个字符变成 word2，那么只要变换到这一步再 +1 插入操作就行了，变换到这一步由于插入一个就行了，因此 word1 比 word2 少一个单词，其它都一样，要变换到这一步，就要进行 dp(i,j-1) 的变换，因此 dp(i,j) = dp(i,j-1) + 1。  
这三种情况取最小即可，即 dp(i,j) = min(dp(i-1,j-1), dp(i,j-1), dp(i-1,j)) + 1。  
再考虑终止条件，即 i 或 j 为 -1 时的情况，因为状态转移方程 i 和 j 不断减小，肯定会减少到 0 或 -1，因为 0 是字符串还有一个字符，相对比如考虑 -1 字符串为空时方便，因此我们考虑 -1 时作为边界条件。  
当 i 为 -1 时，即 word1 为空，此时要变换为 word2 很显然，只有插入 j 次是最小操作次数，因此此时 dp(i,j) = j；同理，当 j 为 -1 时，即 word2 为空，此时要删除 i 次，因此操作次数为 i，所以 dp(i,j) = i。
## 非字符串问题  
非字符串场景的动规比较经典的有三个，第一是矩形路径最小距离，或者最大收益；第二是背包问题以及变种；第三是打家劫舍问题。  
对于 dp(i) 的定义略有区别，比如对于矩形问题来说，dp(i,j) 表示走到 i,j 格子时的最小路径；对于背包问题，dp(i,j) 表示装了第 i 个物品时，背包还剩 j 空间时最大价格；对于打家劫舍问题，dp(i) 表示打劫到第 i 个房间时最大收益。  
对于矩形问题，状态转移方程重点看上个状态是如何转移过来的，一般矩形只能向右或者向下移动，路途可能有一些障碍物不能走，我们要做分支判断，然后选择一条符合题目最值要求的路线作为当前 dp(i) 的转移方程即可。  
对于打家劫舍问题，由于不能同时打劫相邻的房屋，所以对于 dp(i)，要么为了打劫 i-1 而不打劫第 i 间，或者打劫 i-2 于第 i 间，取这两种终态的收益最大值即可，即 dp(i) = max(dp(i-1), dp(i-2) + coins[i])。

参考:  
[精读《算法 - 动态规划》](https://github.com/ascoders/weekly/blob/master/%E7%AE%97%E6%B3%95/198.%E7%B2%BE%E8%AF%BB%E3%80%8A%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8B.md)
