# 前端开发中的流程自动化与提效实践
**新建项目第一步：脚手架**  
如果项目选型是 Angular 的话，那么选择不多可以直接上 Angular CLI；如果是 React 或 Vue 的话，那么会有不少脚手架可以选择，国内很多开发者都有开源不同方案。其中，大多方案会有一些组件库、开源库的绑定，如果你希望一个更加自由的框架搭建，官方脚手架 create-create-app (CRA) 肯定会是第一选择  
通过 npx 执行如下命令，可以通过 CRA 快速创建一个 TypeScript 项目：  
``` 
npx create-react-app project --template typescript
```
随着 CRA 的发展，官方脚手架也将原来暴露在模版中的越来越多细节封装到 react-scripts 包里，简单举个例子，比如你想修改项目 webpack 构建流程，用官方模版无法直接上手。  
官方模版提供了 npm run eject 命令，执行这个命令会将潜藏的一系列配置文件和一些依赖项都 “弹出” 到项目中，然后就可以由你自己完全控制增删，但是该操作是不可逆的。在配置文件被 “弹出” 后，你后续将无法跟随官方的脚步去升级项目所使用的 react-script 版本了。  
**样式隔离方案：CSS Modules**  
这可能是一个已经被大家熟知且默认开启的选项了，其起源也在于对组件样式的隔离需求，且如果你的项目是一个 CRA 官方其实已经支持对 CSS Modules 的启用，按照规定的格式命名你的样式文件，CRA 便可自动对样式进行解析处理。  
如果想做一些样式 loader 的修改，就比如默认的解析方式不支持样式变量的驼峰式命名。要达到目的，可以在集成 craco 后在配置 craco.config.js 中这么写，扩充 css loader 配置选项：  
``` 
module.exports = {
   style: {
     css: {
       mode: "extends",
       loaderOptions: {
         modules: {
           auto: true,
           exportLocalsConvention: 'camelCaseOnly',
         },
       },
     },
   },
 };
```
TypeScript 文件中引用 CSS Modules 变量时，由于 TypeScript 并不知道除了 .ts 以及 .tsx 文件外的文件内容，为了防止 IDE 在语法检查上报错，针对特定文件后缀声明下环境变量。针对 CRA 新建的项目，可以简单建立一个 react-app-env.d.ts 文件来补充上如下说明：  
``` 
/// <reference types="node" />
 /// <reference types="react" />
 /// <reference types="react-dom" />
 /// <reference types="react-scripts" />

 declare module '*.module.css' {
   const classes: { readonly [key: string]: string };
   export default classes;
 }

 declare module '*.module.scss' {
   const classes: { readonly [key: string]: string };
   export default classes;
 }

 declare module '*.module.sass' {
   const classes: { readonly [key: string]: string };
   export default classes;
 }
```
通过 craco 你还可以修改些其他内容，比如配置 babel 不对 ES6 模块做转译、修改打包路径、自定义热更新方案等等  
**ESLINT 代码检查：两个自定义 lint 场景分享**  
为了保证统一一致的代码风格，比如在项目中避免使用 var，可以引入 eslint rules 对提交的代码进行规范。当然，如今大多数脚手架在新建项目时，应该都替你集成好了 eslint，要么是 .eslintrc.json、.eslintrc.js 或者直接在 package.json 中添加 eslintConfig 属性开干。  
除了开启默认的规则集外，在开发过程中，为了让项目在多人之间能够更高效地推进协作开发，肯定有不少细节需要处理  
当我们对代码做了一些增删操作，就可能产生冗余的 import 声明，这个时候我们当然希望它在提交时被删除  
在 eslint 中，插件可以暴露额外的规则以供使用。如果要达到我们刚刚说的目的，这个时候可以引入 unused-imports 插件对 es6 imports 进行代码检查（比如对于未使用到的 import 声明进行 error 提示）：  
``` 
{
    "plugins": ["unused-imports"],
   "rules": {
     "no-unused-vars": "off",
     "unused-imports/no-unused-imports": "error",
     "unused-imports/no-unused-vars": [
       "warn",
       { "vars": "all", "varsIgnorePattern": "^_", "args": "after-used", "argsIgnorePattern": "^_" }
     ]
   }
 }
```
借助 IDE 或者 IDE 插件，还可以前置到每次保存时执行对 import 引用的清理。  
多人协作中还容易出现一类问题，那就是代码冲突。当多人同时修改一个文件时，可能会同时引入新的模块，如果不对代码进行统一风格管理，那么很容易出现 “import 冲突”。为了解决这个问题，可以引入 simple-import-sort 插件，插件还支持对 export 进行排序处理：  
``` 
{
   "plugins": ["simple-import-sort"],
   "rules": {
     "simple-import-sort/imports": "error",
     "simple-import-sort/exports": "error"
   }
 }
```
从 React 17 开始，可以通过配置 eslint rules 达到无需在代码中引入 React 的目的，关于这一部分的实现可以参考 React 官方指导，以下为一段简单的前后代码对比：  
``` 
// 以前
 import React from 'react';

 function App() {
   return <h1>Hello World</h1>;
 }

 // 现在
 function App() {
   return <h1>Hello World</h1>;
 }
```
**自动化环境配置：git hook 钩子定义**  
husky 是一个为 git 客户端增加 hook 的工具，可以被用于配置本地自动化环境。可以安装 husky 并定制我们需要的 git 钩子及具体需要执行的任务，这样可以方便在对代码执行 git 操作时，在特定时机对代码进行特定的检查与处理，常见的钩子有如下两个：  
- commit-msg - 提交信息钩子，在执行 git commit 或者 git merge 时触发
- pre-commit - 预先提交钩子，在执行 git commit 时触发

一段 husky 安装和初始化代码：  
``` 
npm install husky -D
 npx husky-init && npm install // 添加任务一条 commit-msg 钩子
 npx husky add .husky/commit-msg './node_modules/.bin/commitlint --from=HEAD~1'
```
可以结合 commitlint 工具，在 commit-msg 阶段针对 commit 信息进行检查和处理（如上代码所示），又或者在 pre-commit 阶段对将要提交的代码进行格式化操作。  
**自定义命令调用：代码风格统一与 commit 信息规范**  
对于 commit 信息来说，五花八门的书写风格，也十分不利于阅读和维护，比如，当我们需要翻阅历史提交来定位具体 commit 所带来的代码变动时，这依赖于规范的 commit 信息。借助 commitlint 可以帮助我们达到这一点  
commitlint 需要配合 husky 一起使用，具体来说，通过 husky 来保证针对具体钩子的命令配置，通过 commitlint 保证 命令执行能够对 commit msg 信息进行特定检查。一个简单的 commitlint 安装和配置如下：  
``` 
# 安装
 npm install --save-dev @commitlint/{config-conventional,cli}

 # 配置
 echo "module.exports = {extends: ['@commitlint/config-conventional']}" > commitlint.config.js
```
配置了 commitlint 之后，若是使用默认配置，那么只有当我们的 commit msg 符合如下规范时，commit 操作才能正常完成执行，否则中断（其中 scope 为可选）：  
``` 
 <type>(<scope>): description
```
在添加了 commitlint 配置文件后，我们可能会看到 IDE 对这个文件的检查标红，由于在项目构建中我们并不关注该配置文件的格式等内容（因为他只是对 commitlint 的简单配置），所以我们可以在 eslint 配置文件中将其忽略掉。同样的，如果有其他的文件属于类似的定位，你也可以一并将其加入：  
``` 
{
   "ignorePatterns": ["commitlint.config.js"]
 }
```

参考:  
[前端开发中的流程自动化与提效实践](https://mp.weixin.qq.com/s/bRlG5tc244ZVmPdb4mjbGQ)
