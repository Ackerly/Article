# 超长溢出头部省略打点
## 利用 direction 实现头部超长溢出打点
单行超长溢出打点，都是实现在尾部的，代码也非常简单，像是这样：  
``` 
<p>Make CSS Ellipsis Beginning of String</p>

p {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
```
可以通过 direction，将省略打点的位置，从尾部移动至头部：  
``` 
p {
    direction: rtl;
}
```
简单介绍一下 direction：
- direction：CSS 中的 direction 用于设置文本排列的方向。 rtl 表示从右到左 (类似希伯来语或阿拉伯语)， ltr 表示从左到右

另外两个与排版相关的属性还有：  
- writing-mode：定义了文本水平或垂直排布以及在块级元素中文本的行进方向
- unicode-bidi：它与 direction 非常类似，两个会经常一起出现。在现代计算机应用中，最常用来处理双向文字的算法是Unicode 双向算法。而 unicode-bidi 这个属性是用来重写这个算法的

**direction: rtl 会导致使用下划线 _ 连接的数字内容排版错误**  
添加一个简单的结构：  
``` 
<div>
    13993199751_18037893546_4477657
</div>
<div>
    13993199751_18037893546_4477656
</div>
<div>
    13993199751_18037893546_4477655
</div>

div {
    width: 180px;
    overflow: hidden;
    text-overflow: ellipsis;
    direction: rtl;
    white-space: nowrap;
}
```
虽然实现了头部打点，但是数字结尾好像不是我们想要的结果  
这是由于 direction 在处理纯数字、非纯数字文本上的规则不一致，我们再来看这么一段测试代码：  
``` 
<div>
    11111_22222_33333_44444
</div>
<div>
    11111 22222 33333 44444
</div>
<div>
    aaaaa bbbbb ccccc dddddd eeeeee
</div>
<div>
    aaaaa_11111_22222_33333_44444
</div>
```
CSS 层面不考虑溢出情况，仅作用 direction: rtl  
``` 
div {
    width: 240px;
    di
```
对于纯数字的文本内容，数字的排列顺序也会跟着相应的书写顺序，进行反向排列  

## 多方案解决



原文:  
[超长溢出头部省略打点，坑这么大，技巧这么多？](https://mp.weixin.qq.com/s/bxzCf8Xr_aYbeE2msqDnmg)
